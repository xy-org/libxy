import xy.ctti;
import libxy.noncrypto.hash;
import libxy.memory;
import libc~[Clib{headers=@{"string.h"}}] in c;

import libxy.(stdio, string);

-HashBits := %(Size'toBits);

*struct Map~[
    ;; Type of kyes
    key: Any,

    ;; Type of values
    value: Any,

    ;; Hash function to use
    hash: Any = LocalHash{},
] {
    untyped: MapUntyped,
}

*func len(m: Map) = m.untyped'len;

*func set(
    map: mut Map, key: don Any, value: don Any,
    hash: HashBits = ^hash(key, LocalHash{}), # TODO map..hash
    cmp: Func = (
        func indirectCmp(a: Ptr, b: Ptr) = [^$cmp(map..key, map..key)](
            [a~(map..key)], [b~(map..key)]
        )
    ),
) = -> void
>> assumeCompatibleTypes(map..key, key)
>> assumeCompatibleTypes(map..value, value)
{
    map.untyped'set(
        hash, key'addrof, key'sizeof, value'addrof, value'sizeof,
        cmp'toCallback((:Ptr, :Ptr)->Int)
    );
};

*func get(
    map: Map, key: Any,
    hash: HashBits = ^hash(key, LocalHash{}), # TODO map..hash
    cmp: pseudo Func = (
        func indirectCmp(a: Ptr, b: Ptr) = [^$cmp(map..key, map..key)](
            [a~(map..key)], [b~(map..key)]
        )
    ),

    keyAddr: Ptr = key'addrof, keySize: Usize = key'sizeof,
    cmpCb: (:Ptr, :Ptr)->Int = cmp'toCallback((:Ptr, :Ptr)->Int),
    valSize: Usize = sizeof(map..value),
) -> map[ Ptr~[^map..value] ]
>> assumeCompatibleTypes(map..key, key)
{
    return map.untyped'get(hash, valSize, keyAddr, keySize, cmpCb);
}

*func del(
    map: Map, key: Any,
    hash: HashBits = ^hash(key, LocalHash{}), # TODO map..hash
    cmp: Func = (
        func indirectCmp(a: Ptr, b: Ptr) = [^$cmp(map..key, map..key)](
            [a~(map..key)], [b~(map..key)]
        )
    ),
) = -> void
>> assumeCompatibleTypes(map..key, key)
{
    map.untyped'del(
        hash, map..value'sizeof, key'addrof, key'sizeof, cmp'toCallback((:Ptr, :Ptr)->Int)
    );
};

*func has(
    map: Map, key: Any,
    hash: HashBits = ^hash(key, LocalHash{}), # TODO map..hash
    cmp: pseudo Func = (
        func indirectCmp(a: Ptr, b: Ptr) = [^$cmp(map..key, map..key)](
            [a~(map..key)], [b~(map..key)]
        )
    ),
) = -> (res: Bool)
>> assumeCompatibleTypes(map..key, key)
{
    res = map.untyped'has(
        hash, key'addrof, key'sizeof, cmp'toCallback((:Ptr, :Ptr)->Int)
    );
};
