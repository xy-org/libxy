import libxy.memory;
import libc~[Clib{headers=@{"string.h"}}] in c;
import libxy.(stdio, string);

-HashBits := %(Size'toBits);

struct MapUntyped {
    keyArr: Ptr~Byte;
    valArr: Ptr~Byte;
    hashArr: Ptr~HashBits;
    denseCapacity: Usize;; capacity of the buffers above

    indices: Ptr~Size;
    # TODO indices capacity grows by powers of two so we can store
    # the capacity in a simple byte
    indicesCapacity: Usize;; capacity of the indices dynamic array

    ;; number of deleted elements
    lenDeleted: Usize;

    ;; number of elements in the map
    len: Usize;
}

*func len(m: MapUntyped) = m.len;

*func set(
    map: mut MapUntyped,
    hash: HashBits,
    keyPtr: Ptr, keySize: Usize,
    valPtr: Ptr, valSize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) {
    idx := map.len + map.lenDeleted;; Add new elements at the end

    map'insertIndex(idx'to(Size), ...);

    map'ensureDenseCapacity(map.len + 1, =keySize, =valSize);
    c.memcpy(map.keyArr + idx * keySize, keyPtr, keySize);
    c.memcpy(map.valArr + idx * valSize, valPtr, valSize);
    map.hashArr[idx] = hash;
    map.len++;
}

func insertIndex(
    map: MapUntyped, idx: Size, hash: HashBits, keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) {
    ;; We always try to keep around 25% free (i.e. 3/4 utilization) b/c
    ;; insertion/lookup will loop until an empty index is found.
    ;; If we fill the indices array completely then insertion may hang
    numEmptyIndices := map.indicesCapacity - map.len - map.lenDeleted;
    minFree := map.indicesCapacity / 4;
    if (numEmptyIndices <= minFree) {
        map'growIndices(keySize, cmp);
    }

    map'doInsertIndex(...);
}

func doInsertIndex(
    map: MapUntyped, idx: Size, hash: HashBits, keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) {
    bucket : mut = hash'to(Usize) \rem map.indicesCapacity;
    while (map.indices[bucket] > 0z) {
        ix := map.indices[bucket] - 1z;
        alreadyPresent := map.hashArr[ix] == hash &&
                          [cmp](keyPtr, map.keyArr + ix'to(Usize) * keySize) == 0;
        if (alreadyPresent) {
            ;; already present
            # TODO call dtor
            break;
        }
        bucket = (bucket + 1) \rem map.indicesCapacity;
    }
    map.indices[bucket] = idx + 1;
}

func deleteIndex(
    map: MapUntyped, hash: HashBits, keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) -> Size {
    bucket : mut = hash'to(Usize) \rem map.indicesCapacity;
    while (map.indices[bucket] != 0z) {
        ix := map.indices[bucket] - 1z;
        alreadyPresent := ix >= 0z && map.hashArr[ix] == hash &&
                          [cmp](keyPtr, map.keyArr + ix'to(Usize) * keySize) == 0;
        if (alreadyPresent) {
            map.indices[bucket] = -1z;
            # TODO call dtor
            return ix;
        }
        bucket = (bucket + 1) \rem map.indicesCapacity;
    }
    return -1z;
}

*func get(
    map: MapUntyped,
    hash: HashBits,
    valSize : Usize,
    keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) -> Ptr {
    ix := map'findIndex(hash, keyPtr, keySize, cmp);
    if (ix >= 0) {
        return (map.valArr + ix'to(Usize) * valSize)~[void];
    }
    return Ptr{};
}

*func del(
    map: MapUntyped,
    hash: HashBits,
    valSize : Usize,
    keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int
) {
    ix := map'deleteIndex(hash, keyPtr, keySize, cmp);
    if (ix >= 0) {
        map.len--;
        map.lenDeleted++;
        ;; mark the hash in order to know that we are not goint to use this
        ;; again
        map.hashArr[ix] = map.hashArr[ix]'not;
    }
}

*func has(
    map: MapUntyped,
    hash: HashBits,
    keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) -> Bool
{
    ix := map'findIndex(hash, keyPtr, keySize, cmp);
    return ix >= 0z;
}

func findIndex(
    map: MapUntyped, hash: HashBits,
    keyPtr: Ptr, keySize: Usize,
    cmp: (:Ptr, :Ptr)->Int,
) -> Size {
    bucket : mut = hash'to(Usize) \rem map.indicesCapacity;
    while (map.indices[bucket] != 0z) {
        ix := map.indices[bucket] - 1z;
        alreadyPresent := ix >= 0z && map.hashArr[ix] == hash &&
                          [cmp](keyPtr, map.keyArr + ix'to(Usize) * keySize) == 0;
        if (alreadyPresent) {
            return ix;
        }
        bucket = (bucket + 1) \rem map.indicesCapacity;
    }
    return -1z;
}

func growIndices(
    map: mut MapUntyped, keySize: Usize, cmp: (:Ptr, :Ptr)->Int,
) {
    capacity := max(8uz, 2 * map.indicesCapacity);

    indMem: Memory;
    indMem'realloc(capacity * sizeof(Size));

    prevIndices := map.indices;
    prevIndicesCapacity := map.indicesCapacity;

    map.indices = indMem.addr~[Size];
    map.indicesCapacity = capacity;

    ;; fill the new indices
    for (i in :prevIndicesCapacity) {
        if (prevIndices[i] <= 0z) {
            continue;
        }
        ix := prevIndices[i] - 1z;
        hash := map.hashArr[ix];
        keyPtr := map.keyArr + ix'to(Usize) * keySize;
        map'doInsertIndex(ix, hash, keyPtr, keySize, cmp);
    }

    oldInd: mut = Memory{prevIndices~Byte, prevIndicesCapacity};
    oldInd'free();
}

func ensureDenseCapacity(
    map: mut MapUntyped, required: Usize, keySize: Usize, valSize: Usize
) {
    if (required > map.denseCapacity) {
        capacity := max(8uz, 2 * map.denseCapacity);

        keyMem: mut = Memory{map.keyArr, map.denseCapacity * keySize};
        keyMem'realloc(capacity * keySize);
        map.keyArr = keyMem.addr;

        valMem: mut = Memory{map.valArr, map.denseCapacity * valSize};
        valMem'realloc(capacity * valSize);
        map.valArr = valMem.addr;

        hashSize := HashBits'sizeof;
        hashMem: mut = Memory{map.hashArr~[Byte], map.denseCapacity * hashSize};
        hashMem'realloc(capacity * hashSize);
        map.hashArr = hashMem.addr~[HashBits];

        map.denseCapacity = capacity;
    }
}