import libc~[Clib{headers=@{"string.h"}}] in c;
import xy.sys;
import libxy.(string, stdio, list, slice, memory);

*struct CliSchema {
    name: String,
    desc: String,
    epilog: String,
    short: String,

    named: List~CliParam,
    positional: List~CliParam,

    prefixLong: String,
    prefixShort: String,

    noShortGrouping: Bool,
    manualHelp: Bool,
}

*struct CliParam {
    name: String,
    desc: String,
    arg: String,
    short: Char,
    nargs: RangeInt,
    positional: Bool,
    greedy: Bool,
    command: Bool,
}

*func config(
    schema: mut CliSchema, prefixLong: String = "--", prefixShort: String = "-",
    manualHelp := false
) {
    schema .= {
        prefixLong=prefixLong'copy, prefixShort=prefixShort'copy, =manualHelp,
        noShortGrouping= prefixLong != prefixShort,
    };
}

*func prog(
    schema: mut CliSchema, name: String = "", short: String = "", desc: String = "", epilog: String = "",
) {
    schema.name =< name'copy;
    schema.desc =< desc'copy;
    schema.epilog =< epilog'copy;
    schema.short =< short'copy;
    schema.named'append(CliParam{"help"'copy, desc="show this help message and exit"'copy});
}

*func param(
    schema: mut CliSchema,
    name: String = "",
    short := Char{},
    desc: String = "",
    arg: String = "value",
    positional := false,
    nargs : RangeInt = if (positional) 1:2 else 0:1,
    greedy := false,
    command := false,
) {
    field := CliParam{
        name=name'copy, =short, desc=desc'copy, arg=arg'copy, =nargs, =greedy, =command
    };

    if (positional) {
        schema.positional'append(field =>);
    } else {
        schema.named'append(field =>);
    }
}

func command(
    schema: mut CliSchema,
    name: String,
    desc := "",
) {
    # TODO implement
}

*func append(fstr: mut Fstring, schema: CliSchema) {
    if (schema.short'any) {
        fstr @= { schema.name, schema.short, "\n\n" };
    }

    fstr @= { "Usage: ", schema.name };

    for (param in schema.named) {
        fstr @= " ";
        if (param.nargs.begin == 0) {
            fstr @= "[";
        }
        if (param.short != Char{}) {
            fstr @= { "-", param.short };
        } else {
            fstr @= { "--", param.name };
        }
        if (param.arg'any) {
            fstr @= { " <", param.arg, ">" };
        }
        if (param.nargs.begin == 0) {
            fstr @= "]";
        }
    }
    for (param in schema.positional) {
        fstr @= " ";
        if (param.nargs.begin == 0) {
            fstr @= "[";
        }
        fstr @= { "<", param.name, ">" };
        if (param.nargs.begin == 0) {
            fstr @= "]";
        }
    }
    fstr @= "\n";

    if (schema.desc'isEmpty'not) {
        fstr @= { "\n", schema.desc, "\n" };
    }

    ;; print positional
    if (schema.positional'len > 0) {
        fstr @= "\nPositional Arguments:\n";
    }
    for (param in schema.positional) {
        fstr @= "  ";
        if (param.arg'isEmpty'not) {
            fstr @= { "<", param.name, ">" };
        }
        if (param.desc'isEmpty'not) {
            fstr @= { " - ", param.desc };
        }
        fstr @= "\n";
    }

    ;; print named a.k.a. options
    if (schema.named'len > 0) {
        fstr @= "\nOptions:\n";
    }
    for (param in schema.named) {
        fstr @= "  ";
        if (param.short != Char{}) {
            fstr @= { "-", param.short };
            if (param.name'any) {
                fstr @= ", ";
            }
        }
        if (param.name'any) {
            fstr @= { "--", param.name };
        }
        if (param.arg'isEmpty'not) {
            fstr @= { " <", param.arg, ">" };
        }
        fstr @= "\n";
    }

    ;; epilog if any
    if (schema.epilog'isEmpty'not) {
        fstr @= { "\n", schema.epilog, "\n" };
    }
}

struct ParsingError {
    msg: String,
}

*func to(pe: ParsingError, :Bool) pe.msg'isEmpty'not;

*func unhandled(pe: ParsingError) {
    print(pe.msg);
    if (!pe.msg'endswith("\n")) {
        print("\n");
    }
}

*func parse(
    schema: CliSchema, rawArgs := [Global~CmdArgs]
) -> List~CliArg | ParsingError {
    stream : List~CliArg;

    numPositional := schema.positional'len;
    numNamed := schema.named'len;

    nargsPositional : List~Int;
    nargsPositional'fill(numPositional);
    nargsNamed: List~Int;
    nargsNamed'fill(numNamed);

    ;; index of current positional param
    posParamIdx: Size;
    greedyPosParam: Bool;
    ;; >= 0 if we have processed a named param and now waiting for its value
    namedParamIdx: mut = -1;


    for (i in 1:rawArgs.argc) {
        tmp : Ptr = rawArgs.argv[i];
        arg := Str{ tmp, Usize{c.strlen(rawArgs.argv[i])} };

        if (!greedyPosParam && arg'startswith("--"'str)) {
            ;; long form

            if (!schema.manualHelp && arg=="--help"'str) {
                error ParsingError{ f"{schema}" };
            }

            if (namedParamIdx >= 0) {
                error ParsingError{f"Missing value for {schema.named[namedParamIdx].name}"};
            }
            name := arg[2:];

            paramIdx := findParam(schema, name);
            if (paramIdx < 0) {
                error ParsingError{f"Unknown argument {arg}"};
            }

            if (schema.named[paramIdx].arg'isEmpty) {
                stream @= CliArg {
                    name=schema.named[paramIdx].name'copy,
                    value=""~Shared,
                    # dataIdx=schema.named[paramIdx].dataIdx,
                };
                nargsNamed[paramIdx]++;
            } else {
                namedParamIdx = paramIdx;
            }
        } elif (!greedyPosParam && arg'startswith("-"'str)) {
            ;; short form
            for (short in arg[1:]'chars) {
                if (namedParamIdx >= 0) {
                    error ParsingError{f"Missing value for {schema.named[namedParamIdx].name}"};
                }

                paramIdx := findParam(schema, short);
                if (paramIdx < 0) {
                    error ParsingError{f"Unknown argument '-{short}'"};
                }

                if (schema.named[paramIdx].arg'isEmpty) {
                    stream'append(CliArg{
                        name=schema.named[paramIdx].name'copy,
                        value=""~Shared,
                        # dataIdx=schema.named[paramIdx].dataIdx,
                    });
                    nargsNamed[paramIdx]++;
                } else {
                    namedParamIdx = paramIdx;
                }
            }
        } elif (namedParamIdx >= 0) {
            ;; value of named
            stream'append(CliArg{
                name=schema.named[namedParamIdx].name'copy,
                value=String~Shared{addr=arg'memory.addr, size=arg'memory.size},
                # dataIdx=schema.named[namedParamIdx].dataIdx,
            });
            nargsNamed[namedParamIdx]++;
            if (nargsNamed[namedParamIdx] + 1 >= schema.named[namedParamIdx].nargs.end) {
                namedParamIdx = -1;
            } elif (!schema.named[namedParamIdx].greedy) {
                namedParamIdx = -1;
            }
        } else {
            ;; positional
            if (posParamIdx >= numPositional) {
                error ParsingError{f"Unrecognized positional argument '{arg}'"};
            }

            stream'append(CliArg{
                name=schema.positional[posParamIdx].name'copy,
                value=String~Shared{addr=arg'memory.addr, size=arg'memory.size},
                # dataIdx=schema.positional[posParamIdx].dataIdx,
            });
            nargsPositional[posParamIdx]++;
            greedyPosParam = schema.positional[posParamIdx].greedy;
            if (nargsPositional[posParamIdx] + 1 >= schema.positional[posParamIdx].nargs.end) {
                ;; current positional param satisfied. Move to next one.
                posParamIdx++;
                !.greedyPosParam;
            }
        }
    }

    ;; Check for unsatisifed params
    for (i in :numPositional) {
        if (nargsPositional[i] < schema.positional[i].nargs.begin) {
            error ParsingError{
                f"Missing positional parameter '{schema.positional[i].name}'"
            };
        }
    }

    for (i in :numNamed) {
        if (nargsNamed[i] < schema.named[i].nargs.begin) {
            error ParsingError{
                f"Missing parameter '{schema.named[i].name}'"
            };
        }
    }

    return stream;
}

*struct CliArg {
    name: String,
    value: String~Shared,
    # dataIdx: Size,
}

-func findParam(schema: CliSchema, name: Str) -> Int {
    for (idx in :, param in schema.named) {
        if (param.name'str == name) {
            return idx'to(Int);
        }
    }
    return -1;
}

-func findParam(schema: CliSchema, short: Char) -> Int {
    for (idx in :, param in schema.named) {
        if (param.short == short) {
            return idx'to(Int);
        }
    }
    return -1;
}
