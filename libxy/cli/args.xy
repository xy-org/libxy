import libc~[Clib{headers=@{"string.h", "stdio.h"}}] in c;
import xy.sys;
import libxy.string;
import libxy.stdio;
import libxy.array;
import libxy.slice;

*struct CliSchema {
    name: Str~MemStatic;
    desc: Str~MemStatic;
    epilog: Str~MemStatic;
    short: Str~MemStatic;

    named: Array~CliParam;
    positional: Array~CliParam;

    prefixLong: Str~MemStatic;
    prefixShort: Str~MemStatic;

    noShortGrouping: Bool;
}

*struct CliParam {
    name: Str~MemStatic;
    desc: Str~MemStatic;
    arg: Str~MemStatic;
    short: Char;
    nargs: IntInterval;
    positional: Bool;
    greedy: Bool;
    command: Bool;
}

*def config(schema: mut CliSchema, prefixLong := "--", prefixShort := "-") {
    schema .= {
        =prefixLong, =prefixShort,
        noShortGrouping= prefixLong != prefixShort
    };
}

*def prog(schema: mut CliSchema, name := "", short := "", desc := "", epilog := "") {
    schema.name = name;
    schema.desc = desc;
    schema.epilog = epilog;
    schema.short = short;
    schema.named'push(CliParam{"help", short=`h`, desc="show this help message and exit"});
}

*def param(
    schema: mut CliSchema,
    name := "",
    short := Char{},
    desc := "",
    arg := "value",
    positional := false,
    nargs : IntInterval = if (positional) 1:2 else 0:1,
    greedy := false,
    command := false,
) {
    field := CliParam{=name, =short, =desc, =arg, =nargs, =greedy, =command};

    if (positional) {
        schema.positional'push(field);
    } else {
        schema.named'push(field);
    }
}

def command(
    schema: mut CliSchema,
    name: Str~MemStatic,
    desc := "",
) {
    # TODO implement
}

*def append(fstr: mut Fstr, schema: CliSchema) {
    if (schema.short.len > 0) {
        fstr'append(schema.name);
        fstr'append(" - ");
        fstr'append(schema.short);
        fstr'append("\n\n");
    }

    fstr'append("Usage: ");
    fstr'append(schema.name);

    for (arg in schema.named) {
        fstr'append(" ");
        if (arg.nargs.start == 0) {
            fstr'append("[");
        }
        if (arg.short != Char{}) {
            fstr'append("-");
            fstr'append(arg.short);
        } else {
            fstr'append("--");
            fstr'append(arg.name);
        }
        if (arg.arg.len > 0) {
            fstr'append(" <");
            fstr'append(arg.arg);
            fstr'append(">");
        }
        if (arg.nargs.start == 0) {
            fstr'append("]");
        }
    }
    for (arg in schema.positional) {
        fstr'append(" ");
        if (arg.nargs.start == 0) {
            fstr'append("[");
        }
        fstr'append("<");
        fstr'append(arg.name);
        fstr'append(">");
        if (arg.nargs.start == 0) {
            fstr'append("]");
        }
    }
    fstr'append("\n\n");

    fstr'append(schema.desc);
    fstr'append("\n\n");

    fstr'append("Options:\n");
    for (arg in schema.named) {
        fstr'append("  ");
        if (arg.short != Char{}) {
            fstr'append("-");
            fstr'append(arg.short);
            if (arg.name.len > 0) {
                fstr'append(", ");
            }
        }
        if (arg.name.len > 0) {
            fstr'append("--");
            fstr'append(arg.name);
        }
        if (arg.arg.len > 0) {
            fstr'append(" <");
            fstr'append(arg.arg);
            fstr'append(">");
        }
        fstr'append("\n");
    }
    if (len(schema.named) > 0) {
        fstr'append("\n");
    }

    fstr'append(schema.epilog);
    fstr'append("\n");
}

struct ParsingError {
    msg: Str;
}

*def to(pe: ParsingError, :Bool) pe.msg.len > 0;

*def unhandled(pe: ParsingError) {
    print(pe.msg);
    print("\n");
}

*def parse(
    schema: CliSchema, rawArgs := [Global~CmdArgs]
) -> Array~CliArg | ParsingError {
    stream : Array~CliArg;

    numPositional := schema.positional'len;
    numNamed := schema.named'len;

    nargsPositional : Array~Int;
    nargsPositional'fill(numPositional);
    nargsNamed: Array~Int;
    nargsNamed'fill(numNamed);

    ;; index of current positional param
    posParamIdx: Size;
    greedyPosParam: Bool;
    ;; >= 0 if we have processed a named param and now waiting for its value
    namedParamIdx: mut = -1;


    for (i in 1:rawArgs.argc) {
        tmp : Ptr = rawArgs.argv[i];
        arg := Str~MemExt{tmp, c.strlen(rawArgs.argv[i])};

        if (!greedyPosParam && arg'startswith("--")) {
            ;; long form
            if (namedParamIdx >= 0) {
                error ParsingError{f"Missing value for {schema.named[namedParamIdx].name}"};
            }
            name := arg[2:];

            paramIdx := findParam(schema, name);
            if (paramIdx < 0) {
                error ParsingError{f"Unknown argument {arg}"};
            }

            if (schema.named[paramIdx].arg'empty) {
                stream'push(CliArg{
                    name=schema.named[paramIdx].name,
                    value=""~MemExt,
                    # dataIdx=schema.named[paramIdx].dataIdx,
                });
                nargsNamed[paramIdx]++;
            } else {
                namedParamIdx = paramIdx;
            }
        } elif (!greedyPosParam && arg'startswith("-")) {
            ;; short form
            for (short in arg[1:]'chars) {
                if (namedParamIdx >= 0) {
                    error ParsingError{f"Missing value for {schema.named[namedParamIdx].name}"};
                }

                paramIdx := findParam(schema, short);
                if (paramIdx < 0) {
                    error ParsingError{f"Unknown argument '-{short}'"};
                }

                if (schema.named[paramIdx].arg'empty) {
                    stream'push(CliArg{
                        name=schema.named[paramIdx].name,
                        value=""~MemExt,
                        # dataIdx=schema.named[paramIdx].dataIdx,
                    });
                    nargsNamed[paramIdx]++;
                } else {
                    namedParamIdx = paramIdx;
                }
            }
        } elif (namedParamIdx >= 0) {
            ;; value of named
            stream'push(CliArg{
                name=schema.named[namedParamIdx].name,
                value=arg,
                # dataIdx=schema.named[namedParamIdx].dataIdx,
            });
            nargsNamed[namedParamIdx]++;
            if (nargsNamed[namedParamIdx] + 1 >= schema.named[namedParamIdx].nargs.end) {
                namedParamIdx = -1;
            } elif (!schema.named[namedParamIdx].greedy) {
                namedParamIdx = -1;
            }
        } else {
            ;; positional
            if (posParamIdx >= numPositional) {
                error ParsingError{f"Unrecognized positional argument '{arg}'"};
            }

            stream'push(CliArg{
                name=schema.positional[posParamIdx].name,
                value=arg,
                # dataIdx=schema.positional[posParamIdx].dataIdx,
            });
            nargsPositional[posParamIdx]++;
            greedyPosParam = schema.positional[posParamIdx].greedy;
            if (nargsPositional[posParamIdx] + 1 >= schema.positional[posParamIdx].nargs.end) {
                ;; current positional param satisfied. Move to next one.
                posParamIdx++;
                !.greedyPosParam;
            }
        }
    }

    ;; Check for unsatisifed params
    for (i in :numPositional) {
        if (nargsPositional[i] < schema.positional[i].nargs.start) {
            error ParsingError{
                f"Missing positional parameter '{schema.positional[i].name}'"
            };
        }
    }

    for (i in :numNamed) {
        if (nargsNamed[i] < schema.named[i].nargs.start) {
            error ParsingError{
                f"Missing parameter '{schema.named[i].name}'"
            };
        }
    }

    return stream;
}

*struct CliArg {
    name: Str~MemStatic;
    value: Str~MemExt;
    # dataIdx: Size;
}

-def findParam(schema: CliSchema, name: Str) -> Int {
    for (idx in :, param in schema.named) {
        if (param.name == name) {
            return idx'to(Int);
        }
    }
    return -1;
}

-def findParam(schema: CliSchema, short: Char) -> Int {
    for (idx in :, param in schema.named) {
        if (param.short == short) {
            return idx'to(Int);
        }
    }
    return -1;
}
