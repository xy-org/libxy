import libc~[Clib{headers=@{"stdlib.h", "string.h"}}] in c;
import libxy.slice;
import libxy.error;

;; Pair a pointer to some memory with its size.
;;
;; The interpretation of that memory, how it is allocated, how it is to be
;; disposed, an so on is left open. There is no dtor as we don't know how the
;; memory has been allocated.
struct Memory {
    addr: Ptr~Byte;
    size: Size;
}

;; Tag for a managed region block that needs to be deallocated using {free()}
struct MemManaged {}

;; Tag for a memory region that is externally managed. The question of how to
;; deallocate the memory is left to the user of the tag.
struct MemExt {}

;; Tag for a memory region that is part of the static memory and doesn't
;; require deallocation
struct MemStatic {}

*def malloc(size: Size) -> Memory | SystemError {
    addr: Ptr~Byte = c.malloc(size);
    if (addr == Ptr{}) {
        error SystemError{c.ENOMEM};
    }
    return Memory{addr, size};
}

*def realloc(mem: mut Memory, size: Size) -> void | SystemError {
    newMem : Ptr~Byte = c.realloc(mem.addr, size);
    if (newMem == Ptr{}) {
        error SystemError{c.ENOMEM};
    }
    if (size > mem.size) {
        c.memset(newMem + mem.size, 0, size - mem.size);
    }
    mem.addr = newMem;
    mem.size = size;
}

*def free(mem: mut Memory) {
    c.free(mem.addr);
    mem.addr = Ptr{};
    mem.size = 0;
}

*def free(addr: mut Ptr~Byte, size: Size) {
    c.free(addr);
    addr = Ptr{};
}

*def set(mem: Memory, interval: (RangeUlong, RangeUint), ptr: Ptr)
# >> (
#     (ptr + interval'len) <= (mem + interval.start) |
#     (mem + interval.end) <= ptr
# ) ;; assume no overlap
{
    c.memcpy(mem.addr + interval.start, ptr, interval'len);
}

#*def set(mem: Memory, interval: RangeSize, ptr: Ptr) break "sdfsdf";