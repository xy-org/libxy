import xy.ctti;
import libxy.(slice, error, flag);

;; Buf - a binary f-string i.e. a binary string that can be modified
*struct Buf {
    mem: Memory;
    fill: Usize;
}

*func bfstr~[StrCtor{prefix="bf", .interpolation, to=Blob}](
    addr: pseudo Ptr~Byte, size: Usize
) -> Buf {
    res: Buf;
    res.mem'realloc(2*size);; Just a heuristic. But we have to start somewhere
    return res;
}

*func to(buf: mut Buf, :Blob) -> Blob {
    res := Blob{buf.mem.addr =>, buf.fill =>};
    buf.mem.size = 0;
    return res;
}

*func append(buf: mut Buf, addr: Ptr~Byte, size: Usize) -> void {
    buf'ensureCap(size);
    buf.mem[buf.fill +: size] = addr;
    buf.fill += size;
}

*func append(
    buf: mut Buf,
    num: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    endian := Endian{},
) -> void | SystemError {
    buf'ensureCap(num'sizeof);
    converted := num'to(endian);
    buf.mem[buf.fill +: num'sizeof] = converted'addrof;
    buf.fill += num'sizeof;
}

;; Append {bits} to the binary string. Always use big-endian.
*func append(buf: mut Buf, bits: Bits8)  = buf'append(bits'to(Ubyte));
*func append(buf: mut Buf, bits: Bits16) = buf'append(bits'to(Ushort));
*func append(buf: mut Buf, bits: Bits32) = buf'append(bits'to(Uint));
*func append(buf: mut Buf, bits: Bits64) = buf'append(bits'to(Ulong));


;; Append {str} to the buffer
*func append(buf: mut Buf, str: String, nullTerminate := false) =
    buf'append(str'memory, nullTerminate);

*func append(buf: mut Buf, mem: Memory, nullTerminate := false) {
    buf'ensureCap(mem.size + nullTerminate'to(Usize));
    buf.mem[buf.fill +: mem.size] = mem.addr;
    buf.fill += mem.size;
    if (nullTerminate) {
        buf.mem.addr[buf.fill] = 0;
        buf.fill++;
    }
}

;; Append {blob} to the buffer
*func append(buf: mut Buf, blob: Blob~void) {
    buf'ensureCap(blob.size);
    buf.mem[buf.fill +: blob.size] = blob.addr;
    buf.fill += blob.size;
}

func ensureCap(buf: mut Buf, required: Usize) -> void | SystemError {
    if (buf.mem.size - buf.fill < required) {
        newSize := max(required, 2 * buf.mem.size);
        buf.mem'realloc(newSize);
    }
}

*struct Endian {
    val: Byte;

    big:    pseudo = Enum{ 0 };
    little: pseudo = Enum{ 1 };
    host:   pseudo = Enum{ -1 };

    native: pseudo = Enum{ -1 };; Synonym for {host}
    network: pseudo = Enum{ 0 };; Synonym for {big}
}

*func get(endian: Endian, test: Enum) endian.val == test.value'to(Byte);
*func set(endian: mut Endian, new: Enum, set: Bool) {
    endian.val = new.value'to(Byte) * set + endian.val * !set;
}

-littleEndianHost := true; # TODO Get that from somewhere

;; Change endianness of a number
*func to(
    num: (Short, Ushort, Int, Uint, Long, Ulong),
    endian: Endian
) = if ((littleEndianHost && endian.big) || (!littleEndianHost && endian.little)) num'bytes'reverse'to(%num) else num;

;; Just to keep things consistent
*func to(num: (Byte, Ubyte), endian: Endian) = num;

*func dtor(buf: mut Buf) buf.mem'free();