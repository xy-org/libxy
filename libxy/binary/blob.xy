;; Blob - a binary string. The intended purpose of this struct is to be used
;; as-is without modifying it.
;;
;; When tagged with {MemManaged}, the memory is managed by {Blob} itself
;;
;; When tagged with {MemExt}, the memory is managed by something else
;;
;; When tagged with {MemStatic}, the memory needs no deallocation
*struct Blob~[memory := MemManaged] {
    addr: Ptr~Byte;
    size: Usize;
}

*func bstr~[StrCtor{prefix="b"}](addr: Ptr~Byte, size: Usize) =
    Blob~MemStatic{addr, size};

*func bunstr~[UnstrCtor{prefix=""}](:Blob~void) = UnstrIter{};
*func bunstrBe~[UnstrCtor{prefix="be"}](:Blob~void) = UnstrIter{};

*func bunstrLe~[UnstrCtor{prefix="le"}](:Blob~void) =
    UnstrIter{endian=Endian{.little}};

*func dtor(blob: mut Blob~void) = dtor(blob, blob..memory);

*func cmp(lhs: Blob~void, rhs: Blob~void) -> Int {
    if (lhs.size > rhs.size) {
        return 1;
    } elif (lhs.size < rhs.size) {
        return -1;
    }
    return c.memcmp(lhs.addr~[c.char], rhs.addr~[c.char], lhs.size);
}

;; Expose {Blob}'s underlying memory
*func memory(blob: Blob~void) = Memory{blob.addr, blob.size};

;;
;; Unstr functionality
;;

struct UnstrIter {
    offset: Usize;
    endian: Endian;
}

*func read(
    blob: Blob~void, iter: mut UnstrIter,
    num: mut (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    endian : Endian = Endian{iter.endian.val} # TODO why no just endian := iter.endian ???
)
>> (iter.offset <= blob.size) && (blob.size - iter.offset) >= num'sizeof
{
    c.memcpy(num'addrof, blob.addr + iter.offset, num'sizeof);
    iter.offset += num'sizeof;
    num = num'to(endian);
}

*func read(
    blob: Blob~void, iter: mut UnstrIter,
    bits: mut (Bits8, Bits16, Bits32, Bits64),
)

>> (iter.offset <= blob.size) && (blob.size - iter.offset) >= bits'sizeof
{
    c.memcpy(bits'addrof, blob.addr + iter.offset, bits'sizeof);
    iter.offset += bits'sizeof;
    bits = bits'to(Endian{.big});
}

;; I hate this func. There should be a better more expressive way to do that.
-func to(bits: Bits8, endian: Endian) = bits;
-func to(bits: Bits16, endian: Endian) = bits'to(Ushort)'to(endian)'bits;
-func to(bits: Bits32, endian: Endian) = bits'to(Uint)'to(endian)'bits;
-func to(bits: Bits64, endian: Endian) = bits'to(Ulong)'to(endian)'bits;

*func read(
    blob: Blob~void, iter: mut UnstrIter, other: mut Blob~void,
) = read(blob, iter, other, other..memory);

*func read(
    blob: Blob~void, iter: mut UnstrIter, other: mut Blob~void, :MemExt
) {
    if (iter.offset < blob.size) {
        other.addr = blob.addr + iter.offset;
        other.size = blob.size - iter.offset;
    } else {
        other.addr = Ptr{};
        other.size = 0;
    }
    iter.offset += other.size;
}

*func read(
    blob: Blob~void, offset: mut UnstrIter, other: mut Blob~void, :MemStatic
) break "Cannot read into a blob with static memory";

*func read(
    blob: Blob~void, offset: mut UnstrIter, other: mut Blob~void, :MemManaged
) break "Cannot read into a blob with managed memory. Read into Blob~MemExt and then copy";

func dtor(blob: mut Blob~void, :MemManaged) {
    free(blob.addr, blob.size);
}

func dtor(blob: mut Blob~void, :MemStatic) {}
func dtor(blob: mut Blob~void, :MemExt) {}