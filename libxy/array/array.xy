import xy.ctti;
import libxy.(unit, memory, slice, error);
import libc~[Clib{}] in c;

;; A dynamic array. Can grow and shrink as you append and pop elements.
*struct Array~[elemType: struct, xy_dtor=true] {
    mem: Memory;
    len: Size~Count;
}

*def dtor(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.mem'free();
};

*def len(a: Array) = a.len;

def ensureCapacity(
    arr: mut Array,
    requiredCap: Size,
    elemSize : Size = sizeof(arr..elemType)
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

*def append(
    arr: Array,
    elem: pseudo Any,
) = -> void {
    arr'pushBack = elem;
};

-def pushBack(
    arr: mut Array,
    elemSize : Size = sizeof(arr..elemType),
) -> arr[ Ptr~[^arr..elemType] ] {
    pos := arr.len;
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    arr.len++;
    return (arr.mem.addr + pos * elemSize)~[void];
}

*def pop(arr: mut Array) {
    # TODO call dtor;
    if (arr.len > 0) {
        arr.len--;
    }
}

*def get(
    arr: Array, i: (Size, Int, Uint, Long, Ulong),
    elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ]
>> i'to(Size) < arr'len
{
    return (arr.mem.addr + i'to(Size) * elemSize)~void;
}

struct ArrayIter {
    idx: Size;
}

*def iter(arr: Array) -> arr[ ArrayIter ] {
    return ArrayIter{};
}

*def valid(arr: Array, iter: ArrayIter) = iter.idx < arr'len;

*def next(arr: pseudo Array, iter: mut ArrayIter) {
   iter.idx++;
}

*def get(
    arr: Array, iter: ArrayIter, elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + iter.idx * elemSize)~void;
}

*def fill(arr: mut Array, n: Size, value: Any = (arr..elemType){}) =
    for (i in :n) {
        arr'append(value);
    };

;; Clear the array
*def clear(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.len = 0;
};

*def sort(
    arr: mut Array, decreasing := false, stable := false,
) = sort(arr, ^$cmp(arr..elemType, arr..elemType), =decreasing, =stable);

*def sort(
    arr: mut Array, cmp : FuncDef, decreasing := false, stable := false,
) =
    if (!decreasing) {
        cmpCb :=(
            def indirectCmp(
                a: Ptr, b: Ptr, cmp := cmp, elemType := arr..elemType
            ) = [cmp]([a~[%elemType]], [b~[%elemType]])
        )'toCallback((:Ptr, :Ptr)->Int);

        if (stable) {
            auxMem: Memory;
            auxMem'realloc(arr'len * sizeof(arr..elemType));
            sortStable(arr.mem.addr, auxMem.addr, arr'len, cmpCb, sizeof(arr..elemType));
            auxMem'free();
        } else {
            sortUnstable(arr.mem.addr, arr'len, cmpCb, sizeof(arr..elemType));
        }
    } else {
        cmpCb := (
            def indirectCmp(
                a: Ptr, b: Ptr, cmp := cmp, elemType := arr..elemType
            ) = -[cmp]([a~[%elemType]], [b~[%elemType]])
        )'toCallback((:Ptr, :Ptr)->Int);

        if (stable) {
            auxMem: Memory;
            auxMem'realloc(arr'len * sizeof(arr..elemType));
            sortStable(arr.mem.addr, auxMem.addr, arr'len, cmpCb, sizeof(arr..elemType));
            auxMem'free();
        } else {
            sortUnstable(arr.mem.addr, arr'len, cmpCb, sizeof(arr..elemType));
        }
    };


-def sortUnstable(
    arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size
) {
    auxMem: Memory;
    auxMem'realloc(nelems * esize);
    sortStable(arr, auxMem.addr, nelems, cmp, esize);
    auxMem'free();
}


-def sortStable(
    arr: Ptr~Byte, aux: %arr, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size
) {
    ;; merge sort falling back to insertion sort for small arrays
    ;; 16 was chosen completely at random.
    if (nelems <= 16) {
        insertionSort(arr, nelems, cmp, esize);
        return;
    }

    mid := nelems / 2z;
    sortStable(arr, aux, mid, cmp, esize);
    sortStable(arr + mid*esize, aux + mid*esize, nelems-mid, cmp, esize);
    merge(arr, aux, mid, nelems, cmp, esize);
}

def merge(arr: Ptr~Byte, aux: %arr, mid: Size, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size) {

    left: Ptr~Byte = arr;
    right: Ptr~Byte = arr + mid * esize;
    leftLen : mut = mid;
    rightLen := nelems - mid;
    i : mut = 0z;
    j : mut = 0z;
    k : mut = 0z;
    while (i < leftLen && j < rightLen) {
        firstToCopy : mut = i;
        while (i < leftLen && [cmp](left + i * esize, right + j * esize) <= 0) {
            i++;
        }
        if (firstToCopy < i) {
            c.memcpy(aux + k * esize, left + firstToCopy * esize, (i-firstToCopy)*esize);
            k += i - firstToCopy;
        }
        if (i >= leftLen) break;

        firstToCopy = j;
        j++;; We know there is atleast one to copy
        while (j < rightLen && [cmp](left + i * esize, right + j * esize) > 0) {
            j++;
        }
        if (firstToCopy < j) {
            c.memcpy(aux + k * esize, right + firstToCopy * esize, (j-firstToCopy)*esize);
            k += j - firstToCopy;
        }
    }

    if (i < leftLen) {
        c.memcpy(aux + k * esize, left + i * esize, (leftLen - i) * esize);
        k += leftLen - i;
    }
    if (j < rightLen) {
        c.memcpy(aux + k * esize, right + j * esize, (rightLen - j) * esize);
    }

    c.memcpy(arr, aux, nelems * esize);
}

-def insertionSort(
    arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int,
    esize: Size = sizeof(arr..elemType),
) {
    def moveElement(arr: Ptr~Byte, to: Size, from: Size, esize: Size) {
        mem : Memory;
        mem'realloc(esize);
        c.memcpy(mem.addr, arr + from * esize, esize);
        bytesToMove := (from - to) * esize;
        c.memmove(arr + esize * (to + 1), arr + esize * to, bytesToMove);
        c.memcpy(arr + esize * to, mem.addr, esize);
        mem'free();
    }

    ;; the actual insertion sort
    for (i in 1z:nelems) {
        elem : Ptr = arr + esize * i;
        pos := findInsertionPos(arr, i, cmp, esize, elem);

        if (pos < i) {
            arr'moveElement(to=pos, from=i, =esize);
        }
    }
}

def findInsertionPos(
        arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int,
        esize: Size = sizeof(arr..elemType), elem: Ptr,
    ) -> Size {
        low : mut = 0z;
        high : mut = nelems;
        while (low < high) {
            mid := low + ((high - low) / 2z);
            cmpRes := [cmp](arr + esize * mid, elem);
            if (cmpRes > 0) {
                high = mid;
            } else {
                low = mid + 1z;
            }
        }
        return low;
    }

def insert(
     arr: mut Array, pos: Size, elem: pseudo Any,
     elemPtr: Ptr = elem'addrof, esize : Size = elem'sizeof,
) -> void
>> cmpTypes(arr..elemType, elem) >= 0
>> pos <= arr'len
{
    arr'ensureCapacity(arr.len + 1, elemSize=esize);
    bytesToMove := (arr'len - pos) * esize;
    if (bytesToMove > 0) {
        c.memmove(arr.mem.addr + esize * (pos + 1), arr.mem.addr + esize * pos, bytesToMove);
    }
    c.memcpy(arr.mem.addr + esize * pos, elemPtr, esize);
    arr.len++;
}

*def swap(
    arr: mut Array, i: Size, j: Size, esize: Size = sizeof(arr..elemType)
) -> void
>> i < arr'len
>> j < arr'len
{
    if (i != j) {
        mem : Memory;
        mem'realloc(esize);
        c.memcpy(mem.addr, arr.mem.addr + esize * i, esize);
        c.memcpy(arr.mem.addr + esize * i, arr.mem.addr + esize * j, esize);
        c.memcpy(arr.mem.addr + esize * j, mem.addr, esize);
        mem'free();
    }
}


-def lessThan(a: Any, b: Any, cmp: FuncDef, decreasing: Bool) =
    (decreasing && [cmp](a, b) > 0) || (decreasing'not && [cmp](a, b) < 0);
