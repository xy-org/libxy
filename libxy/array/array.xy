import xy.ctti;
import libxy.(unit, memory, slice, error);
import libc~[Clib{}] in c;

;; A dynamic array. Can grow and shrink as you append and pop elements.
*struct Array~[elemType: struct, xy_dtor=true] {
    mem: Memory;
    len: Size~Count;
}

*def dtor(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.mem'free();
};

*def len(a: Array) = a.len;

def ensureCapacity(
    arr: mut Array,
    requiredCap: Size,
    elemSize : Size = sizeof(arr..elemType)
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

*def append(
    arr: Array,
    elem: pseudo Any,
) = -> void {
    arr'pushBack = elem;
};

-def pushBack(
    arr: mut Array,
    elemSize : Size = sizeof(arr..elemType),
) -> arr[ Ptr~[^arr..elemType] ] {
    pos := arr.len;
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    arr.len++;
    return (arr.mem.addr + pos * elemSize)~[void];
}

*def pop(arr: mut Array) {
    # TODO call dtor;
    if (arr.len > 0) {
        arr.len--;
    }
}

*def get(
    arr: Array, i: (Size, Int, Uint, Long, Ulong),
    elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ]
>> i'to(Size) < arr'len
{
    return (arr.mem.addr + i'to(Size) * elemSize)~void;
}

struct ArrayIter {
    idx: Size;
}

*def iter(arr: Array) -> arr[ ArrayIter ] {
    return ArrayIter{};
}

*def valid(arr: Array, iter: ArrayIter) = iter.idx < arr'len;

*def next(arr: pseudo Array, iter: mut ArrayIter) {
   iter.idx++;
}

*def get(
    arr: Array, iter: ArrayIter, elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + iter.idx * elemSize)~void;
}

*def fill(arr: mut Array, n: Size, value: Any = (arr..elemType){}) =
    for (i in :n) {
        arr'append(value);
    };

;; Clear the array
*def clear(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.len = 0;
};

*def sort(
    arr: mut Array, decreasing := false,
) = sort(arr, ^$cmp(arr..elemType, arr..elemType), =decreasing);

*def sort(arr: mut Array, cmp : FuncDef, decreasing := false) =
    if (!decreasing) {
        doSort(arr, (
            def indirectCmp(
                a: Ptr, b: Ptr, cmp := cmp, elemType := arr..elemType
            ) = [cmp]([a~[%elemType]], [b~[%elemType]])
        )'toCallback((:Ptr, :Ptr)->Int));
    } else {
        doSort(arr, (
            def indirectCmp(
                a: Ptr, b: Ptr, cmp := cmp, elemType := arr..elemType
            ) = -[cmp]([a~[%elemType]], [b~[%elemType]])
        )'toCallback((:Ptr, :Ptr)->Int));
    };


-def doSort(
    arr: mut Array, cmp: (:Ptr, :Ptr)->Int, esize: Size = sizeof(arr..elemType)
) {
    range := :arr'len'to(Size);
    arr'insertionSort(range, cmp, =esize);
}

-def insertionSort(
    arr: mut Array, region: RangeSize, cmp: (:Ptr, :Ptr)->Int,
    esize: Size = sizeof(arr..elemType),
) {
    def findInsertionPos(
        arr: mut Array, region: RangeSize, cmp: (:Ptr, :Ptr)->Int,
        esize: Size = sizeof(arr..elemType), elem: Ptr,
    ) -> Size {
        low : mut = region.start;
        high : mut = region.end;
        while (low < high) {
            mid := low + ((high - low) / 2z);
            cmpRes := [cmp](arr.mem.addr + esize * mid, elem);
            if (cmpRes > 0) {
                high = mid;
            } else {
                low = mid + 1z;
            }
        }
        return low;
    }

    def moveElement(arr: mut Array, to: Size, from: Size, esize: Size) {
        mem : Memory;
        mem'realloc(esize);
        c.memcpy(mem.addr, arr.mem.addr + from * esize, esize);
        bytesToMove := (from - to) * esize;
        c.memmove(arr.mem.addr + esize * (to + 1), arr.mem.addr + esize * to, bytesToMove);
        c.memcpy(arr.mem.addr + esize * to, mem.addr, esize);
        mem'free();
    }

    i : mut = region.start + 1z;
    while (i < region.end) {
        sortedRegion := region.start : i;
        elem : Ptr = arr.mem.addr + esize * i;
        pos : mut = findInsertionPos(arr, sortedRegion, cmp, esize, elem);

        if (pos < i) {
            arr'moveElement(to=pos, from=i, =esize);
        }
        i++;
    }
}

def insert(
     arr: mut Array, pos: Size, elem: pseudo Any,
     elemPtr: Ptr = elem'addrof, esize : Size = elem'sizeof,
) -> void
>> cmpTypes(arr..elemType, elem) >= 0
>> pos <= arr'len
{
    arr'ensureCapacity(arr.len + 1, elemSize=esize);
    bytesToMove := (arr'len - pos) * esize;
    if (bytesToMove > 0) {
        c.memmove(arr.mem.addr + esize * (pos + 1), arr.mem.addr + esize * pos, bytesToMove);
    }
    c.memcpy(arr.mem.addr + esize * pos, elemPtr, esize);
    arr.len++;
}

*def swap(
    arr: mut Array, i: Size, j: Size, esize: Size = sizeof(arr..elemType)
) {
    if (i != j) {
        mem : Memory;
        mem'realloc(esize);
        c.memcpy(mem.addr, arr.mem.addr + esize * i, esize);
        c.memcpy(arr.mem.addr + esize * i, arr.mem.addr + esize * j, esize);
        c.memcpy(arr.mem.addr + esize * j, mem.addr, esize);
        mem'free();
    }
}


-def lessThan(a: Any, b: Any, cmp: FuncDef, decreasing: Bool) =
    (decreasing && [cmp](a, b) > 0) || (decreasing'not && [cmp](a, b) < 0);
