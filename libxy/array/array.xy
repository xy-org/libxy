import xy.ctti;
import libxy.(unit, memory, slice, error);

;; A dynamic array. Can grow and shrink as you append and pop elements.
*struct Array~[elemType: struct, xy_dtor=true] {
    mem: Memory;
    len: Size~Count;
}

*def dtor(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.mem'free();
};

*def len(a: Array) = a.len;

def ensureCapacity(
    arr: mut Array,
    requiredCap: Size,
    elemSize : Size = sizeof(arr..elemType)
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

*def append(
    arr: Array,
    elem: pseudo Any,
) = -> void {
    arr'pushBack = elem;
};

-def pushBack(
    arr: mut Array,
    elemSize : Size = sizeof(arr..elemType),
) -> arr[ Ptr~[^arr..elemType] ] {
    pos := arr.len;
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    arr.len++;
    return (arr.mem.addr + pos * elemSize)~[void];
}

*def pop(arr: mut Array) {
    # TODO call dtor;
    if (arr.len > 0) {
        arr.len--;
    }
}

*def get(
    arr: Array, i: (Size, Int, Uint, Long, Ulong),
    elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ]
>> i'to(Size) < arr'len
{
    return (arr.mem.addr + i'to(Size) * elemSize)~void;
}

struct ArrayIter {
    idx: Size;
}

*def iter(arr: Array) -> arr[ ArrayIter ] {
    return ArrayIter{};
}

*def valid(arr: Array, iter: ArrayIter) = iter.idx < arr'len;

*def next(arr: pseudo Array, iter: mut ArrayIter) {
   iter.idx++;
}

*def get(
    arr: Array, iter: ArrayIter, elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + iter.idx * elemSize)~void;
}

*def fill(arr: mut Array, n: Size, value: Any = (arr..elemType){}) =
    for (i in :n) {
        arr'append(value);
    };

;; Clear the array
*def clear(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.len = 0;
};

*def sort(
    arr: mut Array, decreasing := false,
) = sort(arr, ^$cmp(arr..elemType, arr..elemType), =decreasing);

*def sort(arr: mut Array, cmp : FuncDef, decreasing := false) = -> void {
    for (i in 1z:arr'len) {
        elem: arr..elemType;
        elem =< arr[i];
        j : mut = i;
        while (j > 0 && lessThan(elem, arr[j-1], cmp, decreasing)) {
            arr[j] =< arr[j-1];
            j--;
        }
        arr[j] =< elem;
    }
};

-def lessThan(a: Any, b: Any, cmp: FuncDef, decreasing: Bool) =
    (decreasing && [cmp](a, b) > 0) || (decreasing'not && [cmp](a, b) < 0);
