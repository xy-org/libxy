import xy.ctti;
import libxy.(unit, memory, slice, error);
import libc~[Clib{}] in c;

;; A dynamic array. Can grow and shrink as you append and pop elements.
*struct Array~[elemType: struct] {
    mem: Memory;
    len: Size~Count;
}

*def dtor(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.mem'free();
};

*def len(a: Array) = a.len;

def ensureCapacity(
    arr: mut Array,
    requiredCap: Size,
    elemSize : Size = sizeof(arr..elemType)
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

*def append(arr: Array, elem: don Any) = -> void {
    _ := assumeCompatibleTypes(arr..elemType, %elem);
    arr'appendUnsafe(elem'addrof, sizeof(arr..elemType));
    void =< elem;
};

-def appendUnsafe(arr: Array, elemPtr: Ptr, elemSize: Size) {
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    c.memcpy(arr.mem.addr + arr.len * elemSize, elemPtr, elemSize);
    arr.len++;
}

*def pop(arr: mut Array) = if (arr.len > 0) {
    arr[arr.len-1] =< void;
    arr.len--;
};

*def get(
    arr: Array, i: (Int, Uint, Long, Ulong),
    elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ]
>> i'to(Size) < arr'len
{
    return (arr.mem.addr + i'to(Size) * elemSize)~void;
}

struct ArrayIter {
    idx: Size;
}

*def iter(arr: Array) -> arr[ ArrayIter ] {
    return ArrayIter{};
}

*def valid(arr: Array, iter: ArrayIter) = iter.idx < arr'len;

*def next(arr: pseudo Array, iter: mut ArrayIter) {
   iter.idx++;
}

*def get(
    arr: Array, iter: ArrayIter, elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + iter.idx * elemSize)~void;
}

*def fill(arr: mut Array, n: Size, value: Any = (arr..elemType){}) =
    for (i in :n) {
        arr'append(value);
    };

;; Clear the array
*def clear(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.len = 0;
};

*def sort(
    arr: mut Array, decreasing := false, stable := true,
) = sort(arr, ^$cmp(arr..elemType, arr..elemType), =decreasing, =stable);

*def sort(
    arr: mut Array, cmp : FuncDef, decreasing := false, stable := true,
) =
    if (!decreasing) {
        cmpCb :=(
            def indirectCmp(
                a: Ptr, b: Ptr, cmp := cmp, elemType := arr..elemType
            ) = [cmp]([a~[%elemType]], [b~[%elemType]])
        )'toCallback((:Ptr, :Ptr)->Int);

        if (stable) {
            auxMem: Memory;
            auxMem'realloc(arr'len * sizeof(arr..elemType));
            sortStable(arr.mem.addr, auxMem.addr, arr'len, cmpCb, sizeof(arr..elemType));
            auxMem'free();
        } else {
            sortUnstable(arr.mem.addr, arr'len, cmpCb, sizeof(arr..elemType));
        }
    } else {
        cmpCb := (
            def indirectCmp(
                a: Ptr, b: Ptr, cmp := cmp, elemType := arr..elemType
            ) = -[cmp]([a~[%elemType]], [b~[%elemType]])
        )'toCallback((:Ptr, :Ptr)->Int);

        if (stable) {
            auxMem: Memory;
            auxMem'realloc(arr'len * sizeof(arr..elemType));
            sortStable(arr.mem.addr, auxMem.addr, arr'len, cmpCb, sizeof(arr..elemType));
            auxMem'free();
        } else {
            sortUnstable(arr.mem.addr, arr'len, cmpCb, sizeof(arr..elemType));
        }
    };

-def sortUnstable(
    arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size
) {
    # Introsort implementation: hybrid of quicksort insertion sort for small regions
    introsort(arr, nelems, cmp, esize);
}

-def introsort(arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size) {
    if (nelems <= 16) {
        arr'insertionSort(nelems, cmp, esize);
        return;
    }
    # Partition

    mid := nelems / 2z;
    if ([cmp](arr + mid * esize, arr) < 0) {
        unsafeSwap(arr, 0z, mid, esize);
    }
    if ([cmp](arr + (nelems-1) * esize, arr) < 0) {
        unsafeSwap(arr, 0z, nelems-1, esize);
    }
    if ([cmp](arr + (nelems-1)*esize, arr + mid*esize) < 0) {
        unsafeSwap(arr, mid, nelems-1, esize);
    }
    # median is in arr[mid]
    pivotMem: Memory;
    pivotMem'realloc(esize);
    c.memcpy(pivotMem.addr, arr + mid * esize, esize);

    lt : mut = 0z;
    eq : mut = 0z;
    gt : mut = nelems;
    while (eq < gt) {
        cmpRes := [cmp](arr + eq*esize, pivotMem.addr);
        if (cmpRes < 0) {
            unsafeSwap(arr, eq, lt, esize);
            lt++;
            eq++;
        } elif (cmpRes > 0) {
            unsafeSwap(arr, eq, gt-1, esize);
            gt--;
        } else {
            eq++;
        }
    }
    pivotMem'free();

    if (lt > 0) {
        introsort(arr, lt, cmp, esize);
    }
    if (gt < nelems) {
        introsort(arr + gt * esize, nelems - gt, cmp, esize);
    }
}


-def sortStable(
    arr: Ptr~Byte, aux: %arr, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size
) {
    ;; merge sort falling back to insertion sort for small arrays
    ;; 16 was chosen completely at random.
    if (nelems <= 16) {
        insertionSort(arr, nelems, cmp, esize);
        return;
    }

    mid := nelems / 2z;
    sortStable(arr, aux, mid, cmp, esize);
    sortStable(arr + mid*esize, aux + mid*esize, nelems-mid, cmp, esize);
    merge(arr, aux, mid, nelems, cmp, esize);
}

def merge(arr: Ptr~Byte, aux: %arr, mid: Size, nelems: Size, cmp: (:Ptr, :Ptr)->Int, esize: Size) {
    left: Ptr~Byte = arr;
    right: Ptr~Byte = arr + mid * esize;
    leftLen : mut = mid;
    rightLen := nelems - mid;
    i : mut = 0z;
    j : mut = 0z;
    k : mut = 0z;
    while (i < leftLen && j < rightLen) {
        firstToCopy : mut = i;
        while (i < leftLen && [cmp](left + i * esize, right + j * esize) <= 0) {
            i++;
        }
        if (firstToCopy < i) {
            c.memcpy(aux + k * esize, left + firstToCopy * esize, (i-firstToCopy)*esize);
            k += i - firstToCopy;
        }
        if (i >= leftLen) break;

        firstToCopy = j;
        j++;; We know there is atleast one to copy
        while (j < rightLen && [cmp](left + i * esize, right + j * esize) > 0) {
            j++;
        }
        if (firstToCopy < j) {
            c.memcpy(aux + k * esize, right + firstToCopy * esize, (j-firstToCopy)*esize);
            k += j - firstToCopy;
        }
    }

    if (i < leftLen) {
        c.memcpy(aux + k * esize, left + i * esize, (leftLen - i) * esize);
        k += leftLen - i;
    }
    if (j < rightLen) {
        c.memcpy(aux + k * esize, right + j * esize, (rightLen - j) * esize);
    }

    c.memcpy(arr, aux, nelems * esize);
}

-def insertionSort(
    arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int,
    esize: Size = sizeof(arr..elemType),
) {
    def moveElement(arr: Ptr~Byte, to: Size, from: Size, esize: Size) {
        mem : Memory;
        mem'realloc(esize);
        c.memcpy(mem.addr, arr + from * esize, esize);
        bytesToMove := (from - to) * esize;
        c.memmove(arr + esize * (to + 1), arr + esize * to, bytesToMove);
        c.memcpy(arr + esize * to, mem.addr, esize);
        mem'free();
    }

    ;; the actual insertion sort
    for (i in 1z:nelems) {
        elem : Ptr = arr + esize * i;
        pos := findInsertionPos(arr, i, cmp, esize, elem);

        if (pos < i) {
            arr'moveElement(to=pos, from=i, =esize);
        }
    }
}

def findInsertionPos(
        arr: Ptr~Byte, nelems: Size, cmp: (:Ptr, :Ptr)->Int,
        esize: Size = sizeof(arr..elemType), elem: Ptr,
    ) -> Size {
        low : mut = 0z;
        high : mut = nelems;
        while (low < high) {
            mid := low + ((high - low) / 2z);
            cmpRes := [cmp](arr + esize * mid, elem);
            if (cmpRes > 0) {
                high = mid;
            } else {
                low = mid + 1z;
            }
        }
        return low;
    }

def insert(
     arr: mut Array, pos: Size, elem: pseudo Any,
     elemPtr: Ptr = elem'addrof, esize : Size = elem'sizeof,
) -> void
>> cmpTypes(arr..elemType, elem) >= 0
>> pos <= arr'len
{
    arr'ensureCapacity(arr.len + 1, elemSize=esize);
    bytesToMove := (arr'len - pos) * esize;
    if (bytesToMove > 0) {
        c.memmove(arr.mem.addr + esize * (pos + 1), arr.mem.addr + esize * pos, bytesToMove);
    }
    c.memcpy(arr.mem.addr + esize * pos, elemPtr, esize);
    arr.len++;
}

*def swap(
    arr: mut Array,
    i: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong), j: %i,
    esize: Size = sizeof(arr..elemType)
) -> void
>> 0 <= i && i < arr'len
>> 0 <= j && j < arr'len
{
    if (i != j) {
        unsafeSwap(arr.mem.addr, i'to(Size), j'to(Size), esize);
    }
}

-def unsafeSwap(arr: Ptr~Byte, i: Size, j: Size, esize: Size) {
    mem : Memory;
    mem'realloc(esize);
    c.memcpy(mem.addr, arr + esize * i, esize);
    c.memcpy(arr + esize * i, arr + esize * j, esize);
    c.memcpy(arr + esize * j, mem.addr, esize);
    mem'free();
}


-def lessThan(a: Any, b: Any, cmp: FuncDef, decreasing: Bool) =
    (decreasing && [cmp](a, b) > 0) || (decreasing'not && [cmp](a, b) < 0);
