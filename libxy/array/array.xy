import xy.ctti;
import libxy.(unit, memory, slice, error);
import libc~[Clib{}] in c;

;; A dynamic array. Can grow and shrink as you append and pop elements.
*struct Array~[elemType: struct, xy_dtor=true] {
    mem: Memory;
    len: Size~Count;
}

*def dtor(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.mem'free();
};

*def len(a: Array) = a.len;

def ensureCapacity(
    arr: mut Array,
    requiredCap: Size,
    elemSize : Size = sizeof(arr..elemType)
) {
    minRequiredSize := requiredCap * elemSize;
    if (arr.mem.size < minRequiredSize) {
        arr.mem'realloc(max(minRequiredSize, 2 * arr.mem.size));
    }
}

*def append(
    arr: Array,
    elem: pseudo Any,
) = -> void {
    arr'pushBack = elem;
};

-def pushBack(
    arr: mut Array,
    elemSize : Size = sizeof(arr..elemType),
) -> arr[ Ptr~[^arr..elemType] ] {
    pos := arr.len;
    arr'ensureCapacity(arr.len + 1, elemSize=elemSize);
    arr.len++;
    return (arr.mem.addr + pos * elemSize)~[void];
}

*def pop(arr: mut Array) {
    # TODO call dtor;
    if (arr.len > 0) {
        arr.len--;
    }
}

*def get(
    arr: Array, i: (Size, Int, Uint, Long, Ulong),
    elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ]
>> i'to(Size) < arr'len
{
    return (arr.mem.addr + i'to(Size) * elemSize)~void;
}

struct ArrayIter {
    idx: Size;
}

*def iter(arr: Array) -> arr[ ArrayIter ] {
    return ArrayIter{};
}

*def valid(arr: Array, iter: ArrayIter) = iter.idx < arr'len;

*def next(arr: pseudo Array, iter: mut ArrayIter) {
   iter.idx++;
}

*def get(
    arr: Array, iter: ArrayIter, elemSize : Size = sizeof(arr..elemType)
) -> arr[ Ptr~[^arr..elemType] ] {
    return (arr.mem.addr + iter.idx * elemSize)~void;
}

*def fill(arr: mut Array, n: Size, value: Any = (arr..elemType){}) =
    for (i in :n) {
        arr'append(value);
    };

;; Clear the array
*def clear(arr: mut Array) = -> void {
    for (i in :arr'len) {
        arr[i] =< void;
    }
    arr.len = 0;
};

*def sort(
    arr: mut Array, decreasing := false,
) = sort(arr, ^$cmp(arr..elemType, arr..elemType), =decreasing);

def merge(arr: mut Array, r1: RangeSize, r2: RangeSize, cmp: FuncDef, decreasing: Bool) = -> void {
    merged: Array~[arr..elemType];
    i : mut = r1.start;
    j : mut = r2.start;
    while (i < r1.end && j < r2.end) {
        if (lessThan(arr[j], arr[i], cmp, decreasing)'not) {
            merged'append(arr[i] =>);
            i++;
        } else {
            merged'append(arr[j] =>);
            j++;
        }
    }
    while (i < r1.end) {
        merged'append(arr[i] =>);
        i++;
    }
    while (j < r2.end) {
        merged'append(arr[j] =>);
        j++;
    }
    totalBytes := (r1'len + r2'len) * sizeof(arr..elemType);
    c.memcpy(arr.mem.addr + r1.start * sizeof(arr..elemType), merged.mem.addr, totalBytes);
};

*def sort(arr: mut Array, cmp : FuncDef, decreasing := false) = -> void {
    if (arr'len > 1) {
        regions: Array~RangeSize;
        perChunk := 16z;
        for(i in :(arr'len~void):perChunk) {
            range := i:min(arr'len, i+perChunk);
            arr'insertionSort(range, cmp, decreasing);
            regions'append(range);
        }


        while (regions'len > 1) {
            mergedRegions: Array~RangeSize;
            i: mut = 1z;
            while(i < regions'len) {
                merge(arr, regions[i-1], regions[i], cmp, decreasing);
                mergedRegions @= regions[i-1].start:regions[i].end;
                i += 2;
            }
            if (regions'len \mod 2z == 1z) {
                mergedRegions @= regions[regions'len - 1];
            }
            regions =< mergedRegions;
        }
    }
};

-def insertionSort(arr: mut Array, region: RangeSize, cmp : FuncDef, decreasing := false) = -> void {
    i : mut = region.start + 1z;
    while (i < region.end) {
        elem: arr..elemType;
        elem =< arr[i];
        j : mut = i;
        while (j > region.start && lessThan(elem, arr[j-1], cmp, decreasing)) {
            arr[j] =< arr[j-1];
            j--;
        }
        arr[j] =< elem;
        i++;
    }
};

-def lessThan(a: Any, b: Any, cmp: FuncDef, decreasing: Bool) =
    (decreasing && [cmp](a, b) > 0) || (decreasing'not && [cmp](a, b) < 0);
