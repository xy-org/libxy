;; Entity Component Store (a.k.a. Entity Component System w/o the System part)
;; Allows the create of entities and attaching arbitrary data to them.

import xy.ctti;
import libxy.map;

;; Entity Component Store - allows attaching arbitrary data to entities
;; Entities are just placeholders for the data. They don't carry additional
;; Information
*struct Ecs {
    stores: Map~[Uint, DataStore];
    nextEntity: Uint;
}

struct DataStore {
    data: MapUntyped;
}

;; Create new entity
*func entity(db: mut Ecs) -> (entity: Uint) {
    entity = db.nextEntity;
    db.nextEntity++;
}

*func append(
    db: mut Ecs, entity: Uint, data: Any,
) = db'append(entity, staticId(%data), data'addrof, data'sizeof);

func append(
    db: mut Ecs, entity: Uint, dataId: Uint, dataPtr: Ptr, dataSize: Usize
) {

    # TODO replace this with ensure
    if (db.stores'has(dataId)'not) {
        db.stores[dataId] = DataStore;
    }

    indirectCmp := func indirectCmp(a: Ptr, b: Ptr) -> Int {
        return cmp([a~Int], [b~Int]);
    }'toCallback;

    hash: HashBits = entity'to(Ulong)'to(HashBits);

    db.stores[dataId].data'set(
        hash, entity'addrof, entity'sizeof, dataPtr, dataSize,
        indirectCmp,
    );
}

*func has(ecs: Ecs, entity: Uint, data: Any) =
    ecs'hasId(entity, staticId(%data));

func hasId(ecs: Ecs, entity: Uint, dataId: Uint) -> Bool {
    # TODO simplify that
    indirectCmp := func indirectCmp(a: Ptr, b: Ptr) -> Int {
        return cmp([a~Int], [b~Int]);
    }'toCallback;
    hash: HashBits = entity'to(Ulong)'to(HashBits);

    return ecs.stores'has(dataId) && ecs.stores[dataId].data'has(
        hash, entity'addrof, entity'sizeof, indirectCmp
    );
}

*func get(
    db: Ecs, entity: Uint, component: Any,

    dataId: Uint = staticId(component),
    dataSize: Usize = sizeof(component),
) -> db[ Ptr~[^%component] ] {
    if (db.stores'has(dataId)'not) {
        return Ptr;
    }

    indirectCmp := func indirectCmp(a: Ptr, b: Ptr) -> Int {
        return cmp([a~Int], [b~Int]);
    }'toCallback;

    hash: HashBits = entity'to(Ulong)'to(HashBits);

    return db.stores[dataId].data'get(
        hash, dataSize, entity'addrof, entity'sizeof,
        indirectCmp,
    );
}

import libxy.noncrypto.hash;

func hash(num: Uint, :LocalHash) -> Bits64 {
    return num'to(Bits32)'to(Bits64);
}