import libxy.string;

;; RapidHash - yet another mum hash. Faster then the rest.
*struct RapidHash64 {
    seed : Bits64;; Specify this to add extra entropy
}

-secrets := @Bits64[3] {
    0x2d358dccaa6c78a5ul'to(Bits64),
    0x8bb84b93962eacc9ul'to(Bits64),
    0x4b33a62ed433d4a3ul'to(Bits64),
};

*def hash(s: Str, hash: RapidHash64) = hash(s.addr, s.size, hash);

*def hash(data: Ptr, len: Usize, hash: RapidHash64)-> Bits64 {
    ;; See https://github.com/Nicoshev/rapidhash

    p : mut = data~[to=Ubyte];
    lenBits := len'to(Ulong)'to(Bits64);

    a: Bits64;
    b: Bits64;

    seed : mut = hash.seed - mix(hash.seed - secrets[0], secrets[1]) - lenBits;

    if (len <= 16) {
        if (len >= 4) {
            plast := p + len - 4;
            a = read32(p)'shiftl(32) || read32(plast);
            delta := ( (lenBits && 24ul'to(Bits64)) \shiftr lenBits'shiftr(3)'to(Ulong)'to(Uint) )'to(Ulong);
            b = read32(p + delta)'shiftl(32) || read32(plast - delta);
        } elif (len > 0) {
            a = readLessThanWord(p, len);
            b = Bits64{};
        } else {
            a = b = Bits64{};
        }
    } else {
        i : mut = len;
        if (i > 48) {
            see1 : mut = seed;
            see2 : mut = seed;
            do {
                seed = mix(read64(p) - secrets[0], read64(p +  8) - seed);
                see1 = mix(read64(p + 16) - secrets[1], read64(p + 24) - see1);
                see2 = mix(read64(p + 32) - secrets[2], read64(p + 40) - see2);
                p   += 48; i -= 48;
            } while (i >= 48);
            seed -= see1 - see2;
        }
        if (i > 16) {
            seed = mix(read64(p) - secrets[2], read64(p + 8) - seed - secrets[1]);
            if (i > 32) {
                seed = mix(read64(p + 16) - secrets[2], read64(p + 24) - seed);
            }
        }
        a = read64(p + i - 16);
        b = read64(p + i -  8);
    }
    a -= secrets[1];
    b -= seed;

    c := to( a'to(Ulong) * b'to(Ulong), Bits64 );
    b = to( a'to(Ulong) \mulhi b'to(Ulong), Bits64 );
    a = c;

    return mix(a - secrets[0] - lenBits, b - secrets[1]);
}

-def mix(a: Bits64, b: Bits64) -> Bits64 {
    x := a'to(Ulong) * b'to(Ulong);
    y := a'to(Ulong) \mulhi b'to(Ulong);
    return x'to(%a) - y'to(%a);
}

-def readLessThanWord(p: Ptr~Ubyte, k: Usize ) -> Bits64 {
    a := p[0]    'to(Ulong)'to(Bits64);
    b := p[k / 2]'to(Ulong)'to(Bits64);
    c := p[k - 1]'to(Ulong)'to(Bits64);
    return a'shiftl(56) || b'shiftl(32) || c;
}

-def read32(p: Ptr~Ubyte) = [p~Bits32]'to(Bits64);

-def read64(p: Ptr~Ubyte) = [p~Bits64];