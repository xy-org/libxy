import libxy.crypto.random;
import libxy.(binary, slice);
import xytest;

*def sanity~Test() {
    rng : PlatformRng;
    history: @Uint[32];
    for (i in :history'len) {
        history[i] = rng'random(Uint);
        for (j in :i) {
            (assert) history[i] != history[j];
        }
    }
}

*def primTypes~Test() {
    rng : PlatformRng;
    a : Byte = rng'random(Byte);
    b : Ubyte = rng'random(Ubyte);
    c : Short = rng'random(Short);
    d : Ushort = rng'random(Ushort);
    e : Int = rng'random(Int);
    f : Long = rng'random(Long);
    g : Ulong = rng'random(Ulong);
}

*def readingIntoBuf~Test() {
    rng : PlatformRng;
    buf := bf"{rng, 12z}";
    (assert) buf.size == 12z;
    "{n1: Uint}{n2: Uint}{n3: Uint}" = buf;
    (assert) n1 != n2;
    (assert) n1 != n3;
}

*def randomFloatRange~Test() { testFpRange(PlatformRng{}, Float); }
*def randomDoubleRange~Test() { testFpRange(PlatformRng{}, Double); }

-def testFpRange(rng: mut PlatformRng, fpType: pseudo (Float, Double)) {
    for (i in :100) {
        fp := rng'random(fpType);
        (assert) fp >= 0.0'to(%fpType);
        (assert) fp < 1.0'to(%fpType);
    }
}

*def randomFloatExplicitRange~Test() {
    testFpExplicitRange(PlatformRng{}, Float, 5.0:10.0);
}
*def randomDoubleExplicitRange~Test() {
    testFpExplicitRange(PlatformRng{}, Double, 1.61803d:3.14d);
}

-def testFpExplicitRange(
    rng: mut PlatformRng, fpType: pseudo (Float, Double),
    range := %(fpType:fpType),
) {
    for (i in :100) {
        fp := rng'random(range);
        (assert) fp >= range.start;
        (assert) fp < range.end;
    }
}

*def randomFloatDistribution~Test() {
    testRandomDistribution(PlatformRng{}, Float);
}
*def randomDoubleDistribution~Test() {
    testRandomDistribution(PlatformRng{}, Double);
}

;; Very simple way to check if the distribution is atleast sane
-def testRandomDistribution(
    rng: mut PlatformRng, fpType: pseudo (Float, Double)
) {
    nbins := 10;
    perBin := 1000;
    bin : @Int[10];
    binLen := 1.0 / nbins'to(Float);
    allowedMargin := 10;; 10%

    for (i in :nbins * perBin) {
        fp := rng'random(fpType);

        limit : mut = binLen;
        for (j in :nbins) {
            if (fp < limit) {
                bin[j]++;
                break;
            }
            limit += binLen;
        }
    }

    lowerLimit := (perBin * (100 - allowedMargin)) / 100;
    upperLimit := (perBin * (100 + allowedMargin)) / 100;
    for (i in :nbins) {
        (assert) lowerLimit <= bin[i];
        (assert) bin[i] <= upperLimit;
    }
}

*def utils~Test() {
    a := random(Uint);
    b := random(Long);
}

*def generatingIntsSmoke~Test() {
    rng: PlatformRng;
    range := 100:10_000_000;
    a := rng'random(range);
    b := rng'random(range);
    c := rng'random(range);
    (assert) a != b;
    (assert) a != c;
}

*def generatingIntsRange~Test() {
    rng: PlatformRng;
    range := 100:110;
    for (i in :10) {
        rand := rng'random(range);
        (assert) rand >= range.start;
        (assert) rand < range.end;
    }
}
