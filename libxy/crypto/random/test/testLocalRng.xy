import libxy.crypto.random;
import libxy.(binary, slice);
import xytest;

*func sanity~Test() {
    rng : LocalRng;
    history: @Uint[32];
    for (i in :history'len) {
        history[i] = rng'random(Uint);
        for (j in :i) {
            (assert) history[i] != history[j];
        }
    }
}

*func primTypes~Test() {
    rng : LocalRng;
    a : Byte = rng'random(Byte);
    b : Ubyte = rng'random(Ubyte);
    c : Short = rng'random(Short);
    d : Ushort = rng'random(Ushort);
    e : Int = rng'random(Int);
    f : Long = rng'random(Long);
    g : Ulong = rng'random(Ulong);
}

*func readingIntoBuf~Test() {
    rng : LocalRng;
    buf := bf"{rng, 12uz}";
    (assert) buf.size == 12z;
    "{n1: Uint}{n2: Uint}{n3: Uint}" = buf;
    (assert) n1 != n2;
    (assert) n1 != n3;
}

*func randomFloatRange~Test() { testFpRange(LocalRng{}, Float); }
*func randomDoubleRange~Test() { testFpRange(LocalRng{}, Double); }

-func testFpRange(rng: mut LocalRng, fpType: pseudo (Float, Double)) {
    for (i in :100) {
        fp := rng'random(fpType);
        (assert) fp >= 0.0'to(%fpType);
        (assert) fp < 1.0'to(%fpType);
    }
}

*func randomFloatExplicitRange~Test() {
    testFpExplicitRange(LocalRng{}, Float, 5.0:10.0);
}
*func randomDoubleExplicitRange~Test() {
    testFpExplicitRange(LocalRng{}, Double, 1.61803d:3.14d);
}

-func testFpExplicitRange(
    rng: mut LocalRng, fpType: pseudo (Float, Double),
    range := %(fpType:fpType),
) {
    for (i in :100) {
        fp := rng'random(range);
        (assert) fp >= range.start;
        (assert) fp < range.end;
    }
}

*func randomFloatDistribution~Test() {
    testRandomDistribution(LocalRng{}, Float);
}
*func randomDoubleDistribution~Test() {
    testRandomDistribution(LocalRng{}, Double);
}

;; Very simple way to check if the distribution is atleast sane
-func testRandomDistribution(
    rng: mut LocalRng, fpType: pseudo (Float, Double)
) {
    nbins := 10;
    perBin := 1000;
    bin : @Int[10];
    binLen := 1.0 / nbins'to(Float);
    allowedMargin := 20;; 20%

    for (i in :nbins * perBin) {
        fp := rng'random(fpType);

        limit : mut = binLen;
        for (j in :nbins) {
            if (fp < limit) {
                bin[j]++;
                break;
            }
            limit += binLen;
        }
    }

    lowerLimit := (perBin * (100 - allowedMargin)) / 100;
    upperLimit := (perBin * (100 + allowedMargin)) / 100;
    for (i in :nbins) {
        (assert) lowerLimit <= bin[i];
        (assert) bin[i] <= upperLimit;
    }
}

*func utils~Test() {
    a := random(Uint);
    b := random(Long);
}

*func generatingIntsSmoke~Test() {
    rng: LocalRng;
    range := 100:10_000_000;
    a := rng'random(range);
    b := rng'random(range);
    c := rng'random(range);
    (assert) a != b;
    (assert) a != c;
}

*func generatingIntsRange~Test() {
    rng: LocalRng;
    range := 100:110;
    for (i in :10) {
        rand := rng'random(range);
        (assert) rand >= range.start;
        (assert) rand < range.end;
    }
}

*func generatingIntsInvalidRange~Test() {
    rng: LocalRng;

    (assert) rng'random(0:0) == 0;
    (assert) rng'random(0:-1) == 0;
    (assert) rng'random(0:Int'min) == 0;
    (assert) rng'random(Int'max : Int'min) == Int'max;
}

*func generatingIntsLargeRange~Test() {
    rng: LocalRng;

    for (i in :10) {
        (assert) rng'random(0:Int'max) >= 0;
        (assert) rng'random(0:Int'max) < Int'max;
    }

    a := rng'random(Int'min : Int'max);
    b := rng'random(Int'min : Int'max);
    c := rng'random(Int'min : Int'max);

    (assert) a != b;
    (assert) b != c;
}
