import xy.ctti;
import libxy.(binary, slice);
import libc~[Clib{headers=@{"stdlib.h", "math.h"}}] in c;

;; Utility functions

;; Generate a cryptographically strong random number
*def random(
    type: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Float, Double)
) = [Global~PlatformRng]'random(type);

#*def random(
#    range: (IntRange, LongRange, SizeRange, FloatRange, DoubleRange)
#) = [Global~PlatformRng]'random(range);


;; Generate cryptographically strong random numbers
;;
;; This family of functions generate random number using the RNG capabilities
;; of the underlying OS/platform.
;;
;; In theory the OS should be the best source of randomness as userspace
;; processes don't have an easy and reliable source of entropy.
;;
;; The major disadvantage of these functions is speed. Also they cannot be
;; seeded. They are best used to seed other RNGs, generate cookies, keys, etc.
;;
;; Have a look at libxy.noncryto.random if you don't require cryptographically
;; strong randomness (cases include simulations, hashes, etc.)
*struct PlatformRng {}

*def random(rng: pseudo PlatformRng, :Uint) = Uint{c.arc4random()};

*def random(rng: PlatformRng, :Byte  ) = rng'random(Uint)'to(Byte);
*def random(rng: PlatformRng, :Ubyte ) = rng'random(Uint)'to(Ubyte);
*def random(rng: PlatformRng, :Short ) = rng'random(Uint)'to(Short);
*def random(rng: PlatformRng, :Ushort) = rng'random(Uint)'to(Ushort);
*def random(rng: PlatformRng, :Int   ) = rng'random(Uint)'to(Int);

*def random(rng: PlatformRng, :Ulong) -> (res: Ulong) {
    rng'random(res'addrof, res'sizeof);
}

*def random(rng: PlatformRng, :Long) = rng'random(Ulong)'to(Long);

*def random(rng: pseudo PlatformRng, buf: Ptr, size: Size) -> void {
    c.arc4random_buf(buf, size);
}

*def random(rng: PlatformRng, :Float) = random(rng, 0.0:1.0);

*def random(rng: PlatformRng, range: RangeFloat) -> Float {
    precision := 24;; IEEE754 single has 24-bit precision
    rand := ( rng'random(Uint)'to(Bits32)'shiftr(32 - precision) )'to(Uint);
    norm : Float = c.ldexpf(range'len, -precision);
    return range.start + rand'to(Float) * norm;
}

*def random(rng: PlatformRng, :Double) = random(rng, 0.0d:1.0d);

*def random(rng: PlatformRng, range: RangeDouble) -> Double {
    precision := 53;; IEEE754 double has 53-bit precision
    rand := ( rng'random(Ulong)'to(Bits64)'shiftr(64 - precision) )'to(Ulong);
    norm : Double = c.ldexp(range'len, -precision);
    return range.start + rand'to(Double) * norm;
}

;; Generate a random integer uniformly distributed in {range}
*def random(rng: PlatformRng, range: RangeInt) -> Int {
    ;; Based uppon:
    ;; Daniel Lemire, "Fast Random Integer Generation in an Interval".
    ;; Also inspired by freebsd-src/lib/libc/gen/arc4random_uniform.c

    upperBound := range'len;
	if (upperBound <= 1) return range.start;

	product : mut = upperBound'to(Ulong) * rng'random(Uint)'to(Ulong);
	if (product'to(Uint) < upperBound) {
		threshold := -upperBound \mod upperBound;
		while (product'to(Uint) < threshold) {
            product = upperBound'to(Ulong) * rng'random(Uint)'to(Ulong);
        }
	}

	return range.start + product'to(Bits64)'shiftr(32)'to(Bits32)'to(Int);
}

*def append(buf: mut Buf, rng: PlatformRng, size: Size) -> void {
    buf'ensureCap(size);
    rng'random(buf.mem.addr + buf.fill, size);
    buf.fill += size;
}