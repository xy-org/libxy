;; support for flags stored as bitfields

import libxy.bitwise;

*def setFlag(flags: mut Int, mask: Int, on: Bool)
    flags'bits = flags'bits | (mask * on'to(%mask))'bits;

*def getFlag(flags: Int, mask: Int)
    (flags'bits & mask'bits) == mask'bits;

*def andFlag(flags: Int, mask: Int)
    (flags'bits & mask'bits)'to(%flags);

*def orFlag(flags: mut Int, mask: Int)
    (flags'bits | mask'bits)'to(%flags);


*struct Enum {
    value: Int;
}

*def set(value: mut Int, enum: Enum, on: Bool) {
    # TODO make this a macro
    if (on) value = enum.value;
}

*def set(value: mut Uint, enum: Enum, on: Bool) {
    # TODO make this a macro
    if (on) value = enum.value'to(Uint);
}

*def get(value: Uint, enum: Enum) value == enum.value'to(Uint);

*struct Flag {
    value: Int;
}

*def get(value: (Byte, Ubyte, Short, Ushort, Int, Uint), flag: Flag)
    (value'bits & flag.value'to(%value)'bits) == flag.value'to(%value)'bits;

*def set(value: mut (Ubyte, Int, Uint), flag: Flag, on: Bool) {
    if (on) {value'bits = value'bits | flag.value'to(%value)'bits;}
    else {value'bits = value'bits & !flag.value'to(%value)'bits;}
}