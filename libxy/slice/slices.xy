;; Represent a kind of interval spaning from -inf to +inf
*struct AllSlice {
}

*func slice() = AllSlice{};

;; Range is an half-open interval [begin, end}. A step of 1 is implied
*struct RangeByte {
    begin: Byte;
    end: Byte;
}

;; ...
*struct RangeUbyte {
    begin: Ubyte;
    end: Ubyte;
}

;; ...
*struct RangeShort {
    begin: Short;
    end: Short;
}

;; ...
*struct RangeUshort {
    begin: Ushort;
    end: Ushort;
}

;; ...
*struct RangeInt {
    begin: Int;
    end: Int;
}

;; ...
*struct RangeUint {
    begin: Uint;
    end: Uint;
}

;; ...
*struct RangeLong {
    begin: Long;
    end: Long;
}

;; ...
*struct RangeUlong {
    begin: Ulong;
    end: Ulong;
}

*RangeSize := RangeUlong;

;; Range is an half-open interval [start, end}.
*struct RangeFloat {
    begin: Float;
    end: Float;
}

;; ...
*struct RangeDouble {
    begin: Double;
    end: Double;
}

;; A slice represent the list of values in [{start}, {end}) separated by {step}
*struct SliceInt {
    begin: Int;
    end: Int;
    step: Int;
}

# I don't see the point of floating-point slices

;; Construct a slice
*func slice(
    begin: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong)
) = rangeType(begin){begin, (%begin)'max};

*func slice(
    end: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    begin := 0'to(%end)
) = rangeType(begin){begin, end};

*func slice(
    step: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    end := (%step)'max, begin := 0'to(%end)
) = sliceType(begin){begin, end, step};

-func rangeType(:Byte)   = RangeByte;
-func rangeType(:Ubyte)  = RangeUbyte;
-func rangeType(:Short)  = RangeShort;
-func rangeType(:Ushort) = RangeUshort;
-func rangeType(:Int)    = RangeInt;
-func rangeType(:Uint)   = RangeUint;
-func rangeType(:Long)   = RangeLong;
-func rangeType(:Ulong)  = RangeUlong;

-func sliceType(:Byte)   = SliceByte;
-func sliceType(:Ubyte)  = SliceUbyte;
-func sliceType(:Short)  = SliceShort;
-func sliceType(:Ushort) = SliceUshort;
-func sliceType(:Int)    = SliceInt;
-func sliceType(:Uint)   = SliceUint;
-func sliceType(:Long)   = SliceLong;
-func sliceType(:Ulong)  = SliceUlong;

;; Return length of the {range}
;; The returned value is always positive. If begin > end then a 0 is returned.
;; This behavior helps avoid overflow errors. Also in expressions like
;; for (i in a:b) you would expect the loop to not enter even once when a >= b
*func len(
    range: (RangeUbyte, RangeUshort, RangeUint, RangeUlong)
) =
    if (range.end > range.begin) range.end - range.begin
    else 0'to(%range.end);

;; ...
*func len(
    range: (RangeByte, RangeShort, RangeInt, RangeLong)
) =
    if (range.end > range.begin) range.end'unsign - range.begin'unsign
    else 0'to(%range.end'unsign);

-func unsign(a: Byte) a'to(Ubyte);
-func unsign(a: Short) a'to(Ushort);
-func unsign(a: Int) a'to(Uint);
-func unsign(a: Long) a'to(Ulong);

;; Construct a slice
*func slice(begin: Float) = RangeFloat{begin, Float'inf};
*func slice(end: Float, begin := 0.0) = RangeFloat{begin, end};

*func slice(begin: Double) = RangeDouble{begin, Double'inf};
*func slice(end: Double, begin := 0.0d) = RangeDouble{begin, end};

*func len(range: (RangeFloat, RangeDouble)) = range.end - range.begin;
