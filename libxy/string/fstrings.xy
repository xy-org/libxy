import xy.ctti;
import libxy.bitwise;

*struct Fstr~[xy_dtor=true] {
    mem: Memory;
    fill: Size;
}

*def dtor(builder: mut Fstr) {
    builder.mem'free();
}

*def fstr~[StrCtor{prefix="f", interpolation=true, to=Str}] (
    addr: pseudo Ptr, size: Size
) -> Fstr {
    return Fstr{};
}

def ensureCap(builder: mut Fstr, requiredCap: Size) {
    minSize := builder.fill + requiredCap;
    if (builder.mem.size < minSize) {
        newSize : mut = 2 * builder.mem.size;
        if (newSize < minSize) {
            newSize = minSize;
        }
        builder.mem'realloc(newSize + 1);
    }
}

*def append(builder: mut Fstr, addr: Ptr, size: Size) {
    builder'ensureCap(size);
    c.memcpy(builder.mem.addr + builder.fill, addr, size);
    builder.fill += size;
}

*def append(
    builder: mut Fstr, str: Str,
    width := Int'max, minWidth := width, maxWidth := width,
    fill := ` `, left := false, center := false,
    clip: Str = "...",
)
>> !(left && center)
>> if (minWidth != Int'max) maxWidth >= minWidth else true
{
    strCount := str'count;
    minSize := if (minWidth != Int'max) max(minWidth, 0)'to(Size) else 0z;
    maxSize := max(maxWidth, 0)'to(Size);

    if (strCount < minSize) {
        # we have to pad
        padBefore: Size;
        padAfter: Size;
        if (strCount < minSize) {
            if (left) {
                padAfter = minSize - strCount;
            } elif (center) {
                padCount := minSize - strCount;
                padBefore = padCount / 2;
                ;; if {padCount} is not even pad extra after the string
                padAfter = (padCount + 1) / 2;
            } else {
                padBefore = minSize - strCount;
            }
        }

        builder'append(fill, repeat=padBefore'to(Uint));
        builder'append(str.addr, str.size);
        builder'append(fill, repeat=padAfter'to(Uint));
    } elif (strCount > maxSize) {
        # we have to clip
        clipSize := clip'count;
        charsToAdd := if (maxSize >= clipSize) maxSize - clipSize else 0z;
        for (_ in :charsToAdd, char in str'chars) {
            builder'append(char);
        }
        builder'append(clip.addr, clip.size);
    } else {
        # just right
        builder'append(str.addr, str.size);
    }
}

*def append(builder: mut Fstr, str: Fstr) =
    builder'append(str.mem.addr, str.fill);

;; Number of available bytes in builder
def capacity(fstr: Fstr) fstr.mem.size - fstr.fill;

;; Stringify and append {num}
*def append(
    fstr: mut Fstr,
    num: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    base := 10,
)
>> base >= 2 && base <= 36
{
    if (num > 0) {
        fstr'appendDigits(num, base);
    } elif (num < 0) {
        fstr'append(`-`);
        fstr'appendDigits((-num)'unsigned, base);
    } else {
        fstr'append(`0`);
    }
}

-def appendDigits(
    fstr: mut Fstr,
    num:(Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong),
    base: Int,
) {
    number : mut = num;
    numDigits := do -> (i : Size) {
        i++;
        number /= base'to(%number);
    } while (number != 0);

    fstr'ensureCap(numDigits);
    number = num;
    for (i in :numDigits) {
        digit := number \rem base'to(%number);
        digitSymbol := if (digit <= 9) `0` + digit else `A` + digit - 10;
        fstr.mem.addr[fstr.fill + numDigits - i - 1] = digitSymbol'to(Byte);
        number /= base'to(%number);
    }
    fstr.fill += numDigits;
}

;; Stringify and append {bits}
*def append(fstr: mut Fstr, bits: (Bits8, Bits16, Bits32, Bits64)) {
    fstr'ensureCap(2 + bits'sizeof * 2);
    fstr'append("0x");
    letters := c"0123456789ABCDEF";
    num : mut = bits'unsigned'nibbles'reverse.bits'unsigned;
    for (i in :(bits'sizeof*2)) {
        oct := num \rem 16'to(%num);
        num = num / 16;
        fstr.mem.addr[fstr.fill + i] = letters[oct];
    }
    fstr.fill += bits'sizeof*2;
}

def unsigned(a: Byte) a'to(Ubyte);
def unsigned(a: Short) a'to(Ushort);
def unsigned(a: Int) a'to(Uint);
def unsigned(a: Long) a'to(Ulong);
def unsigned(a: Ubyte) a;
def unsigned(a: Ushort) a;
def unsigned(a: Uint) a;
def unsigned(a: Ulong) a;
def unsigned(a: Bits8) a'to(Ubyte);
def unsigned(a: Bits16) a'to(Ushort);
def unsigned(a: Bits32) a'to(Uint);
def unsigned(a: Bits64) a'to(Ulong);

;; ...
*def append(
    fstr: mut Fstr,
    num: (Float, Double),
    precision := -1,
    scientific := false,
) {
    fstr'ensureCap(20z);
    for (_ in :2) {
        capacity := fstr'capacity;

        fmt := if (precision >= 0 && scientific) "%.*e"
             elif (precision >= 0) "%.*f"
             elif (scientific) "%e"
             else "%g";

        added := -> (added: Int) {
            if (precision >= 0) {
                added = c.snprintf(
                    fstr.mem.addr~[c.char] + fstr.fill, capacity,
                   fmt.addr~[to=c.char], precision, num
                );
            } else {
                added = c.snprintf(
                    fstr.mem.addr~[c.char] + fstr.fill, capacity,
                    fmt.addr~[to=c.char], num
                );
            }
        };


        if (added >= 0) {
            if (added'to(%capacity) > capacity) {
                fstr'ensureCap(added'to(%capacity) + 1);
            } else {
                fstr.fill += added'to(%capacity);
                break;
            }
        } else {
            ;; NOTE! Silently ignore this error
            break;
        }
    }
}

;; ...
*def append(
    builder: mut Fstr, flag: Bool,
    falseStr : Str = "false", trueStr : Str = "true",
) {
    if (flag) {
        builder @= trueStr;
    } else {
        builder @= falseStr;
    }
}

*def backtrack(builder: mut Fstr, num: Uint) {
    builder.fill -= num'to(Size);
}

;; Encode {char} to utf-8 and append to str. Invalid chars are ignored.
*def append(builder: mut Fstr, char: Char) {
    builder'ensureCap(4z);
    nchar := char'to(Uint);
    if (nchar <= 0x7F) {
        [builder.mem.addr+builder.fill] = nchar'to(Byte);
        builder.fill += 1;
    } elif (nchar <= 0x07FF) {
        [builder.mem.addr+builder.fill+0] = (0xC0'bits || nchar'bits'shiftr(6))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+1] = (0x80'bits || (0x3F'bits && nchar'bits))'to(Bits8)'to(Byte);
        builder.fill += 2;
    } elif (nchar <= 0xFFFF) {
        [builder.mem.addr+builder.fill+0] = (0xE0'bits || nchar'bits'shiftr(12))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+1] = (0x80'bits || (0x3F'bits && nchar'bits'shiftr(6)))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+2] = (0x80'bits || (0x3F'bits && nchar'bits))'to(Bits8)'to(Byte);
        builder.fill += 3;
    } elif (nchar <= 0x10FFFF) {
        [builder.mem.addr+builder.fill+0] = (0xF0'bits || nchar'bits'shiftr(18))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+1] = (0x80'bits || (0x3F'bits && nchar'bits'shiftr(12)))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+2] = (0x80'bits || (0x3F'bits && nchar'bits'shiftr(6)))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+3] = (0x80'bits || (0x3F'bits && nchar'bits))'to(Bits8)'to(Byte);
        builder.fill += 4;
    }
    ;; Else invalid char. Just ignore.
}

;; ...
*def append(fstr: mut Fstr, char: Char, repeat: Uint) {
    if (repeat > 0) {
        addedBytes := -> (added: Size) {
            added = fstr.fill;
            fstr'append(char);
            added = fstr.fill - added;
        };

        required : mut = repeat'to(Size) - 1;
        available : mut = 1z;
        fstr'ensureCap(addedBytes * required);
        src := fstr.mem.addr + fstr.fill - addedBytes;
        while (required > 0) {
            toTransfer := min(required, available);
            c.memcpy(fstr.mem.addr + fstr.fill, src, toTransfer * addedBytes);
            fstr.fill += toTransfer * addedBytes;
            available += toTransfer;
            required -= toTransfer;
        }
    }
}

*def to(builder: mut Fstr, :Str) -> Str~MemManaged {
    builder'ensureCap(1z);
    ;; not really needed but better safe than sorry
    [builder.mem.addr~[c.char] + builder.fill] = 0;
    res := Str{builder.mem.addr, builder.fill};
    builder.mem =< Memory{};
    return res;
}
