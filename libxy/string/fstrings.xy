import xy.ctti;
import libxy.bitwise;

*struct Fstr~[xy_dtor=true] {
    mem: Memory;
    fill: Size;
}

*def dtor(builder: mut Fstr) {
    builder.mem'free();
}

*def fstr~[StrCtor{prefix="f", interpolation=true, to=Str}] (
    addr: pseudo Ptr, size: Size
) -> Fstr {
    return Fstr{};
}

def ensureCap(builder: mut Fstr, requiredCap: Size) {
    minSize := builder.fill + requiredCap;
    if (builder.mem.size < minSize) {
        newSize : mut = 2 * builder.mem.size;
        if (newSize < minSize) {
            newSize = minSize;
        }
        builder.mem'realloc(newSize + 1);
    }
}

*def append(builder: mut Fstr, addr: Ptr, size: Size) {
    builder'ensureCap(size);
    c.memcpy(builder.mem.addr + builder.fill, addr, size);
    builder.fill += size;
}

*def append(builder: mut Fstr, str: Str) {
    builder'append(str.addr, str.size);
}

*def append(builder: mut Fstr, str: Fstr) =
    builder'append(str.mem.addr, str.fill);

;; Number of available bytes in builder
def capacity(fstr: Fstr) fstr.mem.size - fstr.fill;

def printfFmt(:Byte) inlinec"\"%\"PRId8";
def printfFmt(:Ubyte) inlinec"\"%\"PRIu8";
def printfFmt(:Short) inlinec"\"%\"PRId16";
def printfFmt(:Ushort) inlinec"\"%\"PRIu16";
def printfFmt(:Int) inlinec"\"%\"PRId32";
def printfFmt(:Uint) inlinec"\"%\"PRIu32";
def printfFmt(:Long) inlinec"\"%\"PRId64";
def printfFmt(:Ulong) inlinec"\"%\"PRIu64";
def printfFmt(:Size) inlinec"\"%zu\"";

;; Stringify and append {num}
*def append(
    fstr: mut Fstr,
    num: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Size),
    base := 10,
    minusSign := `-`, plusSign := Char{}, zeroSign := plusSign,
)
>> base >= 2 && base <= 36
{
    if (num > 0) {
        if (plusSign != Char{}) {
            fstr'append(plusSign);
        }
        fstr'appendDigits(num, base);
    } elif (num < 0) {
        if (minusSign != Char{}) {
            fstr'append(minusSign);
        }
        fstr'appendDigits((-num)'unsigned, base);
    } else {
        if (zeroSign != Char{}) {
            fstr'append(zeroSign);
        }
        fstr'append(`0`);
    }
}

-def appendDigits(
    fstr: mut Fstr,
    num:(Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Size),
    base: Int,
) {
    number : mut = num;
    numDigits := do -> (i : Size) {
        i++;
        number /= base'to(%number);
    } while (number != 0);

    fstr'ensureCap(numDigits);
    number = num;
    for (i in :numDigits) {
        digit := number \mod base'to(%number);
        digitSymbol := if (digit <= 9) `0` + digit else `A` + digit - 10;
        fstr.mem.addr[fstr.fill + numDigits - i - 1] = digitSymbol'to(Byte);
        number /= base'to(%number);
    }
    fstr.fill += numDigits;
}

;; Stringify and append {bits}
*def append(fstr: mut Fstr, bits: (Bits8, Bits16, Bits32, Bits64)) {
    fstr'ensureCap(2 + bits'sizeof * 2);
    fstr'append("0x");
    letters := c"0123456789ABCDEF";
    num : mut = bits'unsigned'nibbles'reverse.bits'unsigned;
    for (i in :(bits'sizeof*2)) {
        oct := num \mod 16'to(%num);
        num = num / 16;
        fstr.mem.addr[fstr.fill + i] = letters[oct];
    }
    fstr.fill += bits'sizeof*2;
}

def unsigned(a: Byte) a'to(Ubyte);
def unsigned(a: Short) a'to(Ushort);
def unsigned(a: Int) a'to(Uint);
def unsigned(a: Long) a'to(Ulong);
def unsigned(a: Ubyte) a;
def unsigned(a: Ushort) a;
def unsigned(a: Uint) a;
def unsigned(a: Ulong) a;
def unsigned(a: Size) a;
def unsigned(a: Bits8) a'to(Ubyte);
def unsigned(a: Bits16) a'to(Ushort);
def unsigned(a: Bits32) a'to(Uint);
def unsigned(a: Bits64) a'to(Ulong);

#def appendUnsigned(
#    fstr: mut Fstr,
#    num: (Ubyte, Ushort, Uint, Ulong, Size),
#    base : Ubyte
#) {
#    fstr'ensureCap(num'sizeof * 8);; Worst-case number of symbols
#    rem : mut = num;
#    do {
#        digit := rem \mod base;
#        rem = rem / base;
#
#        #if (digit <= 9) {
#        #    [builder.mem.addr + builder.fill] = (`0` + digit)'to(Byte);
#        #} else {
#        #    [builder.mem.addr + builder.fill] = (`A` + digit)'to(Byte);
#        #}
#        #builder.fill++;
#    } while (rem != 0);
#}

;; ...
*def append(builder: mut Fstr, num: Float, precision:=6) {
    builder'ensureCap(20z);
    added : Int = c.sprintf(builder.mem.addr~[c.char] + builder.fill, c"%.*f", precision, num);
    builder.fill += added'to(Size);
}

;; ...
*def append(builder: mut Fstr, num: Double, precision:=6) {
    builder'ensureCap(20z);
    added : Int = c.sprintf(builder.mem.addr~[c.char] + builder.fill, c"%.*f", precision, num);
    builder.fill += added'to(Size);
}

;; ...
*def append(
    builder: mut Fstr, flag: Bool,
    falseStr : Str = "false", trueStr : Str = "true",
) {
    if (flag) {
        builder @= trueStr;
    } else {
        builder @= falseStr;
    }
}

*def backtrack(builder: mut Fstr, num: Uint) {
    builder.fill -= num'to(Size);
}

;; Encode {char} to utf-8 and append to str. Invalid chars are ignored.
*def append(builder: mut Fstr, char: Char) {
    builder'ensureCap(4z);
    nchar := char'to(Uint);
    if (nchar <= 0x7F) {
        [builder.mem.addr+builder.fill] = nchar'to(Byte);
        builder.fill += 1;
    } elif (nchar <= 0x07FF) {
        [builder.mem.addr+builder.fill+0] = (0xC0'bits || nchar'bits'shiftr(6))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+1] = (0x80'bits || (0x3F'bits && nchar'bits))'to(Bits8)'to(Byte);
        builder.fill += 2;
    } elif (nchar <= 0xFFFF) {
        [builder.mem.addr+builder.fill+0] = (0xE0'bits || nchar'bits'shiftr(12))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+1] = (0x80'bits || (0x3F'bits && nchar'bits'shiftr(6)))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+2] = (0x80'bits || (0x3F'bits && nchar'bits))'to(Bits8)'to(Byte);
        builder.fill += 3;
    } elif (nchar <= 0x10FFFF) {
        [builder.mem.addr+builder.fill+0] = (0xF0'bits || nchar'bits'shiftr(18))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+1] = (0x80'bits || (0x3F'bits && nchar'bits'shiftr(12)))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+2] = (0x80'bits || (0x3F'bits && nchar'bits'shiftr(6)))'to(Bits8)'to(Byte);
        [builder.mem.addr+builder.fill+3] = (0x80'bits || (0x3F'bits && nchar'bits))'to(Bits8)'to(Byte);
        builder.fill += 4;
    }
    ;; Else invalid char. Just ignore.
}

*def to(builder: mut Fstr, :Str) -> Str~MemManaged {
    builder'ensureCap(1z);
    ;; not really needed but better safe than sorry
    [builder.mem.addr~[c.char] + builder.fill] = 0;
    res := Str{builder.mem.addr, builder.fill};
    builder.mem =< Memory{};
    return res;
}
