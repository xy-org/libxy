func cstring~[StrCtor{prefix="c", interpolation=false}] (
    addr: Ptr, size: Usize
) = addr~[c.char];


;; A pointer to a unicode (UTF-8) encoded string
;;
;; The memory is not owned and will not be freed.
;; No guarantee of a terminating null character.
;;
;; Generally speaking {String} is what you are looking for unless you want
;; to do your own memory management
*struct Str {
    addr: Ptr~Byte;
    size: Usize;
}

;; Get a slice of {str}. The result shares memory with the original string.
;; Slicing is byte based.
*func get(
    str: Str,
    range: (RangeByte, RangeUbyte, RangeShort, RangeUshort, RangeInt, RangeUint, RangeLong, RangeUlong),
) -> Str
{
    if (range.begin <= range.end) {
        begin := min(max(range.begin, %range.begin)'to(Usize), str.size);
        end := min(max(range.end, %range.end)'to(Usize), str.size);
        return Str{str.addr + begin, (end - begin)'to(Usize)};
    } else {
        return Str{Ptr, 0uz};
    }
}

;; Search for {needle} in {haystack} return byte offset
*func find(haystack: Str, needle: Str, reverse := false) =
    haystack'memory'find(needle'memory, reverse);

;; Allocate a new {String} object and fill it with the data from {str}
*func to(str: Str, :String) -> (res: String) {
    if (str.size > 0) {
        mem := malloc(str.size + 1);
        mem[:str.size] = str.addr;
        mem.addr[str.size] = 0;
        return string(mem.addr, mem.size - 1, true);
    }
}


;; A managed String
;;
;; String is a Str, but it's owned and managed by the struct, also there is a
;; terminating null character.
*struct String {
-:
    addr: Ptr~Byte;
    size: pseudo = SizeField{};

    isMananaged: pseudo = OwnField{};

    ;; The byte-length of the string as encoding in UTF-8
    ;; + a flag if the memory is owned or not
    packedSize: %Usize'toBits;
}

;; Tag strings that share memory with other strings.
;;
;; Shared strings don't free the memory they use.
*struct Shared~[xyTag := TagCtor{label="shared"}] {}

*func dtor(string: String) {
    if (string.isMananaged) {
        c.free(string.addr);
    }
}

;; Construct a string from memory buffer
;;
;; The memory pointed to by {addr} should have a length of {size},
;; be UTF-8, and NULL terminated.
;;
;; {takeOwnership} controls if we own the string and if we should call free
;; when we are done with it.
;;
;; Two string sharing memory is possible and requires extra caution.
;; Consider labelling such strings {Shared} in order to add a layer of
;; static type safety.
*func string~[StrCtor{prefix="", interpolation=false}] (
    addr: Ptr, size: Usize, takeOwnership := false,
) = String {
    addr=addr,
    packedSize=size'toBits'shiftl(1) || (Usize + takeOwnership)'toBits
};


-struct OwnField {}

func get(str: String, :OwnField) = ( str.packedSize && 1uz'toBits )'to(Usize)'to(Bool);


-struct SizeField {}

func get(str: String, :SizeField) = str.packedSize'shiftr(1)'to(Usize);

func set(str: String, :SizeField, new: Usize) =
    str.packedSize = new'toBits'shiftl(1) || (str.packedSize && 1uz'toBits);


*func get(s: String, int: (RangeInt, RangeUint, RangeUlong)) -> String~Shared
>> int.begin >= 0 && int.begin <= int.end
{
    start := min(int.begin'to(Usize), s.size);
    end := min(int.end'to(Usize), s.size);
    return String{s.addr + start, end - start};
}

;; Return true if string is empty
*func isEmpty(s: String) s.size == 0;

;; Retrun true if string is not empty
*func any(s: String) s.size != 0;

*func cmp(str1: String, str2: String) = cmp(str1'str, str2'str);

*func cmp(str1: Str, str2: Str) -> Int {
    if (str1.size > str2.size) {
        return 1;
    } elif (str1.size < str2.size) {
        return -1;
    }
    return c.strncmp(str1.addr~[c.char], str2.addr~[c.char], str1.size);
}

*func copy(str: String) -> String {
    newmem : Memory;
    newmem'realloc(str.size + 1);
    c.memcpy(newmem.addr, str.addr, str.size);
    [newmem.addr + str.size] = 0;; add terminating \0
    return string(newmem.addr, str.size, true);
}

struct CharIter {
    i: Usize;; byte-offset of the code point after {char} in string
    char: Char;; character at that offset
}

*func get(str: (String, Str), charIter: CharIter) = charIter.char;

;; Iterate of the unicode characters (code points) in {str}
;; Illegal byte sequences are replaced by U+FFFD
*func chars~IterCtor(str: (String, Str)) -> str[ CharIter ] {
    iter : CharIter;
    next(str, iter);
    return iter;
}

*func valid(str: (String, Str), iter: CharIter) iter.char'to(Int) >= 0;

*func next(str: (String, Str), iter: mut CharIter) {
    iter.char = decode(str, iter.i);
}

func decode(s: String, i: mut Usize) = decode(s'str, i);

func decode(s: Str, i: mut Usize) -> Char {
    if (i >= s.size) {
        return (-1)'to(Char);
    }

    cp : Int;
    leadingByte := s.addr[i];
    leadingOnes := leadingByte'bits'countLeadingOnes;
    i++;

    if (leadingOnes >= 2 && leadingOnes <= 4) {
        cp'bits = 0xFF'bits'shiftr(leadingOnes+1) && leadingByte'bits'to(Bits32);
        contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
        for (_ in 0:contBytes) {
            contOnes := s.addr[i]'bits'countLeadingOnes;
            if (contOnes == 1) {
                cp'bits = cp'bits'shiftl(6) || (0x3Fub'bits && s.addr[i]'bits)'to(Bits32);
            } elif (contOnes != 1 && contOnes <= 4) {
                # premature end of current sequence. Break b/c
                # a new sequence is following
                cp = -1;
                break;
            } else {
                # broken byte.
                cp = -1;
            }
            i++;
        }
    } elif (leadingOnes == 0) {
        ;; Ascii symbol
        cp = leadingByte'to(Int);
    } else {
        ;; Broken byte
        cp = -1;
    }

    if (cp < 0) {
        cp = 0xFFFD;; Replace invalid bytes by replacement char
    }

    return cp'to(Char);
}

;; Convert {String} to {Str}
;; The returned value shared memory with {s}
*func str(s: String) = Str{s.addr, s.size};

;; Expose the underlying memory managed by String
;;
;; The memory contains the string UTF-8 encoded. The momory's size is the size
;; in bytes. The terminating null character is not counted in the size.
*func memory(s: String) = Memory{s.addr, s.size};

;; ...
*func memory(s: Str) = Memory{s.addr, s.size};

;; Convert the string to a Blob
;;
;; The terminating null character is counted in the resulting blob size.
*func blob(s: don String) -> (res: Blob~MemManaged) {
    res = Blob~MemManaged{s.addr, s.size};
    s =< void;
}

;; Return true if {pattern} is found in {text}
*func has(text: String, pattern: String) = text'memory'find(pattern'memory) >= 0z;

;; === Encoding into a Blog ===

;; Append {str} to the buffer
*func append(buf: mut Buf, str: String, nullTerminate := false) =
    buf'append(str'memory, nullTerminate);
