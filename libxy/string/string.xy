func cstr~[StrCtor{prefix="c", interpolation=false}] (
    addr: Ptr, size: Usize
)
    addr~[c.char];

;; A Unicode String
;;
;; The string in stored in UTF-8 wich means access to individual chars
;; is only sequential and not random.
*struct String {
-:
    addr: Ptr~Byte;
    size: pseudo = SizeField{};

    isMananaged: pseudo = OwnField{};

    ;; The byte-length of the string as encoding in UTF-8
    ;; + a flag if the memory is owned or not
    packedSize: %Usize'toBits;
}

;; Tag strings that share memory with other strings.
;;
;; Shared strings don't free the memory they use.
*struct Shared~[xyTag := TagCtor{label="shared"}] {}

;; Used internally to differentiate between shared and proper strings
-struct NotShared~[xyTag := TagCtor{label="shared"}] {}

*func dtor(str: String) = dtor(str, str..(shared, NotShared));

func dtor(str: String, :NotShared) {
    if (str.isMananaged) {
        c.free(str.addr);
    }
}

func dtor(str: String, :Shared) {
    # noop. Ignore ownershipt information.
}

;; Construct a string from memory buffer
;;
;; The memory pointed to by {addr} should have a length of {size},
;; be UTF-8, and NULL terminated.
;;
;; {takeOwnership} controls if we own the string and if we should call free
;; when we are done with it.
;;
;; Two string sharing memory is possible and requires extra caution.
;; Consider labelling such strings {Shared} in order to add a layer of
;; static type safety.
*func str~[StrCtor{prefix="", interpolation=false}] (
    addr: Ptr, size: Usize, takeOwnership := false,
) = String {
    addr=addr,
    packedSize=size'toBits'shiftl(1) || (Usize + takeOwnership)'toBits
};


-struct OwnField {}

func get(str: String, :OwnField) = ( str.packedSize && 1uz'toBits )'to(Usize)'to(Bool);


-struct SizeField {}

func get(str: String, :SizeField) = str.packedSize'shiftr(1)'to(Usize);

func set(str: String, :SizeField, new: Usize) =
    str.packedSize = new'toBits'shiftl(1) || (str.packedSize && 1uz'toBits);


func get(s: String, i: Usize) -> Byte
>> i < s.size
{
    return [(s.addr)~[to=Byte] + i];
}

;; Count the number of unicode code points (chars) in the string
;; Illegal byte sequences are counted as 1 code point
*func count(s: String) -> Usize {
    res : Usize;
    i : Usize;
    while (i < s.size) {
        leadingOnes := s[i]'bits'countLeadingOnes;
        res++;
        i++;
        if (leadingOnes >= 2 && leadingOnes <= 4) {
            contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
            for (_ in 0:contBytes) {
                contOnes := s[i]'bits'countLeadingOnes;
                if (contOnes != 1 && contOnes <= 4) {
                    # premature end of current sequence. Break b/c
                    # a new sequence is following
                    break;
                }
                # else if {contOnes} == 1 then we have a valid seq
                # if {contOnes} is > 4 then we have a broken byte and we want
                # to skip it
                i++;
            }
        }
        ;; if {leadingOnes == 0} then ascii otherwise broken byte
    }
    return res;
}

*func get(s: String, int: (RangeInt, RangeUint, RangeUlong)) -> String~Shared
>> int.start >= 0 && int.start <= int.end
{
    start := min(int.start'to(Usize), s.size);
    end := min(int.end'to(Usize), s.size);
    return String{s.addr + start, end - start};
}

;; Return true if string is empty
*func isEmpty(s: String) s.size == 0;

;; Retrun true if string is not empty
*func any(s: String) s.size != 0;

*func cmp(str1: String, str2: String) -> Int {
    if (str1.size > str2.size) {
        return 1;
    } elif (str1.size < str2.size) {
        return -1;
    }
    return c.strncmp(str1.addr~[c.char], str2.addr~[c.char], str1.size);
}

*func startswith(str: String, prefix: String) -> Bool {
    if (prefix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char], prefix.addr~[c.char], prefix.size);
    return strncmpRes == 0;
}

*func endswith(str: String, suffix: String) -> Bool {
    if (suffix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char] + (str.size - suffix.size), suffix.addr~[c.char], suffix.size);
    return strncmpRes == 0;
}

*func ensureNullTerminated(str: String) ensureNullTerminated(str, str..(share, NotShared));
func ensureNullTerminated(str: String, :NotShared) str;
func ensureNullTerminated(str: String, :Shared) str'copy();

*func isNullTerminated(str: String) isNullTerminated(str, str..(shared, NotShared));
func isNullTerminated(str: String, :NotShared) true;
func isNullTerminated(str: String, :Shared) false;

*func copy(str: String) -> String {
    newmem : Memory;
    newmem'realloc(str.size + 1);
    c.memcpy(newmem.addr, str.addr, str.size);
    [newmem.addr + str.size] = 0;; add terminating \0
    return str(newmem.addr, str.size, true);
}

struct CharIter {
    i: Usize;; byte-offset of the code point after {char} in string
    char: Char;; character at that offset
}

*func get(str: String, charIter: CharIter) = charIter.char;

;; Iterate of the unicode characters (code points) in {str}
;; Illegal byte sequences are replaced by U+FFFD
*func chars~IterCtor(str: String) -> str[ CharIter ] {
    iter : CharIter;
    next(str, iter);
    return iter;
}

*func valid(str: String, iter: CharIter) iter.char'to(Int) >= 0;

*func next(str: String, iter: mut CharIter) {
    cp := decode(str, iter.i);
    iter.char = cp;
}

func decode(s: String, i: mut Usize) -> Char {
    if (i >= s.size) {
        return (-1)'to(Char);
    }

    cp : Int;
    leadingByte := s[i];
    leadingOnes := leadingByte'bits'countLeadingOnes;
    i++;

    if (leadingOnes >= 2 && leadingOnes <= 4) {
        cp'bits = 0xFF'bits'shiftr(leadingOnes+1) && leadingByte'bits'to(Bits32);
        contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
        for (_ in 0:contBytes) {
            contOnes := s[i]'bits'countLeadingOnes;
            if (contOnes == 1) {
                cp'bits = cp'bits'shiftl(6) || (0x3Fub'bits && s[i]'bits)'to(Bits32);
            } elif (contOnes != 1 && contOnes <= 4) {
                # premature end of current sequence. Break b/c
                # a new sequence is following
                cp = -1;
                break;
            } else {
                # broken byte.
                cp = -1;
            }
            i++;
        }
    } elif (leadingOnes == 0) {
        ;; Ascii symbol
        cp = leadingByte'to(Int);
    } else {
        ;; Broken byte
        cp = -1;
    }

    if (cp < 0) {
        cp = 0xFFFD;; Replace invalid bytes by replacement char
    }

    return cp'to(Char);
}

;; Expose the underlying memory managed by String
;;
;; The memory contains the string UTF-8 encoded. The momory's size is the size
;; in bytes. The existance of a terminating null character can be determined by
;; {isNullTerminated}. If present it is NOT counted in the memory size.
*func memory(s: String) = Memory{s.addr, s.size};

-struct BytesField {}

;; Expose a pointer to the memory manged by String
;;
;; This method exist simply to provided better interface for access to
;; individual bytes and slices based on byte offsets
*func bytes(s: String) -> s[ BytesField, ... ] {
    return BytesField;
}

*func get(s: String, :BytesField) = s.addr;

*func get(
    str: String, :BytesField,
    range: (RangeByte, RangeUbyte, RangeShort, RangeUshort, RangeInt, RangeUint, RangeLong, RangeUlong),
) -> String~Shared
>> range.start >= 0
>> range.start'to(Usize) < str.size && range.end'to(Usize) <= str.size
{
    if (range.start <= range.end) {
        return String~Shared{str.addr + range.start, range'len'to(Usize)};
    } else {
        return String~Shared{Ptr, 0uz};
    }
}


;; Split by (white)space characters
*func split~IterCtor(str: String) -> str[ SplitIter ] {
    si: mut = SplitIter{.valid};
    next(str, si);
    return si;
}

*func valid(str: String, iter: SplitIter) = iter.valid;

*func get(str: String, iter: SplitIter) = iter.word;

*func next(str: String, iter: mut SplitIter) {
    istart := do -> (istart: Usize) {
        istart = iter.ichar.i;
        next(str, iter.ichar);
        if (!valid(str, iter.ichar)) {
            !.iter.valid;
            return;
        }
    } while (str[iter.ichar]'space);

    iend := do -> (iend: Usize) {
        iend = iter.ichar.i;
        next(str, iter.ichar);
        if (!valid(str, iter.ichar)) {
            break;
        }
    } while (!str[iter.ichar]'space);

    iter.word = String~Shared{str.addr + istart, iend - istart};
}

struct SplitIter {
    ichar: CharIter;
    word: String~Shared;
    valid: Bool;
}

*func space(ch: Char) -> Bool {
    return ch == `\n` || ch == ` `;
}

;; Return true if {needle} is found in {haystack}
*func has(haystack: String, needle: String) = haystack'find(needle) >= 0z;


;; Search for {needle} in {haystack}.
-func find(haystack: String, needle: String, reverse := false) =
    if (reverse'not) ffind(haystack, needle) else rfind(haystack, needle);

-func ffind(haystack: String, needle: String) -> Size {
    if (needle.size == 0) return 0z;; memmem is inconsistent if needle is empty

    location: Ptr~Byte = c.memmem(
        haystack.addr, haystack.size, needle.addr, needle.size
    );
    if (location >= haystack.addr) {
        # TODO use pointer arithmatic
        s := haystack.addr;
        return Size{ inlinec"({location} - {s})" };
    } else {
        return -1z;
    }
}

-func rfind(haystack: String, needle: String) -> Size {
    if (needle.size == 0) return 0z;

    res: mut = -1z;

    text: mut = String{haystack.addr, haystack.size};
    offset: Usize;
    while (true) {
        loc := find(text, needle);
        if (loc >= 0) {
            res = offset'to(Size) + loc;
            text.addr += loc'to(Usize) + 1uz;
            text.size -= loc'to(Usize) + 1uz;
            offset += loc'to(Usize) + 1uz;
        } else {
            break;
        }
    }

    return res;
}
