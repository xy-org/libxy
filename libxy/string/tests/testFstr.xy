import libxy.string;
import xytest;

*def interpolatingChar~Test() {
    (assert) f"{`a`}" == "a";
    (assert) f"{`Ğ¶`}" == "Ğ¶";
    (assert) f"{`ğŸ˜Š`}xyz" == "ğŸ˜Šxyz";
    (assert) f"abc{`ğŸ˜Š`}" == "abcğŸ˜Š";
    (assert) f"before{`ğŸ˜Š`}after" == "beforeğŸ˜Šafter";
}

*def interpolatingStr~Test() {
    str := "John";
    (assert) f"My name is {str}" == "My name is John";

    # Case folding in unicode is a mess. For now I am going to
    # not bother implementing it.
    # (assert) f"My name is {str, .upper}" == "My name is JOHN";
    # (assert) f"My name is {str, .lower}" == "My name is john";
    # (assert) f"{str, fill=`*`, width=10, .center}" == "***John***";
}

#*def strInterpolationUnicode~Test() {
#    str := "Ğ™Ğ¾Ğ°Ğ½";
#    (assert) "My name is {str}" == "My name is Ğ™Ğ¾Ğ°Ğ½";
#    (assert) "My name is {str, .upper}" == "My name is Ğ™ĞĞĞ";
#    (assert) "My name is {str, .lower}" == "My name is Ğ¹Ğ¾Ğ°Ğ½";
#    (assert) "{str, fill=`âˆ`, width=6, .center}" == "âˆĞ™Ğ¾Ğ°Ğ½âˆ";
#}

*def interpolatingInt~Test() {
    (equal) f"{1b}", "1";
    (equal) f"{12ub}", "12";
    (equal) f"{123s}", "123";
    (equal) f"{4us}", "4";
    (equal) f"{12345}", "12345";
    (equal) f"{6u}", "6";
    (equal) f"{-1234567l}", "-1234567";
    (equal) f"{8ul}", "8";
    (equal) f"{369z}", "369";
}

*def interpolatingIntExplicitBase~Test() {
    (equal) f"{789024328ul, base=10}", "789024328";
    (equal) f"{789024328ul, base=16}", "2F078E48";
    (equal) f"{789024328ul, base=8}", "5701707110";
    (equal) f"{789024328ul, base=2}", "101111000001111000111001001000";
    (equal) f"{789024328ul, base=27}", "20QIFO7";
    (equal) f"{48461859, base=36}", "SUPER";
}

*def interpolatingBits~Test() {
    (equal) f"{0xFE()b'to(Bits8)}", "0xFE";
    (equal) f"{0x1234s'to(Bits16)}", "0x1234";
    (equal) f"{0x123456'to(Bits32)}", "0x00123456";
    (equal) f"{0x123456ABCDEFul'to(Bits64)}", "0x0000123456ABCDEF";
}

*def plusSign~Test() {
    (equal) f"{500, plusSign=`+`}", "+500";
    (equal) f"{500, plusSign=` `}", " 500";
    (equal) f"{-500, plusSign=`+`}", "-500";
    (equal) f"{0, plusSign=`+`, minusSign=`-`}", "+0";
    (equal) f"{0, plusSign=`+`, minusSign=`-`, zeroSign=Char{}}", "0";
}

*def interpolatingFloat~Test() {
    (assert) f"{4125.6, precision=1}" == "4125.6";
    #(assert) f"{4125.6d}" == "4125.6";
    #(assert) f"{3.0}" == "3.0";
    #(assert) f"{3.0d}" == "3.0";
    #(assert) f"{float'inf}" == "inf";
    #(assert) f"{-float'inf}" == "inf";
    #(assert) f"{float'nan(.quiet)}" == "nan";
    #(assert) f"{double'nan(quiet=False)}" == "nan";
}

#*def scientificNotation~Test() {
#    num := 3.14;
#    (assert) f"{num, .scientific}" == "3.140000e+00";
#    (assert) f"{num, .scientific, precision=2}" == "3.14e+00";
#}
#
#*def fill~Test() {
#    num := 128s;
#    str := "String";
#    (assert) f"{num, width=5, fill=`*`}" == "**128";
#    (assert) f"{str, width=10, fill=`.`}" == "..String..";
#    (assert) f"{num, width=7, fill=`É™`, .center}" == "É™É™128É™É™";
#    (assert) f"{"!", width=3, fill=`ğŸ˜Š`}" == "ğŸ˜ŠğŸ˜Š!";
#}
#
#*def group~Test() {
#    num := 12345;
#    fnum := 12345.6789;
#    (assert) f"{num, group=`_`}" == "12_345";
#    (assert) f"{fnum, group=`_`}" == "12_345.6789";
#    (assert) f"{fnum, group=`_`, precision=0}" == "12_345";
#    (assert) f"{fnum, group=`,`, precision=2}" == "12,345.67";
#}
#
#*def clip~Test() {
#    str := "Very long string";
#    (assert) f"{str, width=10}" == "Very long string";
#    (assert) f"{str, width=str'len, clip="..."}" == "Very long string";
#    (assert) f"{str, width=str'len-1, clip="..."}" == "Very long st...";
#    (assert) f"{str, width=5, clip="âš âš âš "}" == "Veâš âš âš ";
#    (assert) f"{str, width=2, clip="..."}" == "..";
#}
#
#*def precision~Test() {
#    num := 4125.6;
#    (assert) f"{num, precision=2}" == "4125.60";
#    (assert) f"{num, precision=1}" == "4125.6";
#    (assert) f"{num, precision=0}" == "4125";
#    (assert) f"{num, precision=-1}" == "4125";
#}
#