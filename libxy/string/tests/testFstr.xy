import libxy.string;
import xytest;

*def interpolatingChar~Test() {
    (assert) f"{`a`}" == "a";
    (assert) f"{`ж`}" == "ж";
    (assert) f"{`😊`}xyz" == "😊xyz";
    (assert) f"abc{`😊`}" == "abc😊";
    (assert) f"before{`😊`}after" == "before😊after";
}

*def interpolatingStr~Test() {
    str := "John";
    (assert) f"My name is {str}" == "My name is John";

    # Case folding in unicode is a mess. For now I am going to
    # not bother implementing it.
    # (assert) f"My name is {str, .upper}" == "My name is JOHN";
    # (assert) f"My name is {str, .lower}" == "My name is john";
    # (assert) f"{str, fill=`*`, width=10, .center}" == "***John***";
}

#*def strInterpolationUnicode~Test() {
#    str := "Йоан";
#    (assert) "My name is {str}" == "My name is Йоан";
#    (assert) "My name is {str, .upper}" == "My name is ЙОАН";
#    (assert) "My name is {str, .lower}" == "My name is йоан";
#    (assert) "{str, fill=`⁈`, width=6, .center}" == "⁈Йоан⁈";
#}

*def interpolatingInt~Test() {
    (equal) f"{1b}", "1";
    (equal) f"{12ub}", "12";
    (equal) f"{123s}", "123";
    (equal) f"{4us}", "4";
    (equal) f"{12345}", "12345";
    (equal) f"{6u}", "6";
    (equal) f"{-1234567l}", "-1234567";
    (equal) f"{8ul}", "8";
    (equal) f"{369z}", "369";
}

*def interpolatingIntExplicitBase~Test() {
    (equal) f"{789024328ul, base=10}", "789024328";
    (equal) f"{789024328ul, base=16}", "2F078E48";
    (equal) f"{789024328ul, base=8}", "5701707110";
    (equal) f"{789024328ul, base=2}", "101111000001111000111001001000";
    (equal) f"{789024328ul, base=27}", "20QIFO7";
    (equal) f"{48461859, base=36}", "SUPER";
}

*def interpolatingBits~Test() {
    (equal) f"{0xFE()b'to(Bits8)}", "0xFE";
    (equal) f"{0x1234s'to(Bits16)}", "0x1234";
    (equal) f"{0x123456'to(Bits32)}", "0x00123456";
    (equal) f"{0x123456ABCDEFul'to(Bits64)}", "0x0000123456ABCDEF";
}

*def interpolatingFloat~Test() {
    (equal) f"{4125.6, precision=1}", "4125.6";
    (equal) f"{4125.6d}", "4125.6";
    (equal) f"{3.0}", "3";
    (equal) f"{3.0d, precision=1}", "3.0";
    (equal) f"{2.9, precision=0}", "3";
    (equal) f"{3.14, precision=-1}", "3.14";

    (equal) f"{Float'inf}", "inf";
    (equal) f"{Double'inf}", "inf";
    (equal) f"{-Double'inf}", "-inf";
    (equal) f"{Float'nan}", "nan";
    (equal) f"{-Double'nan}", "nan";
}

*def scientificNotation~Test() {
    num := 3.14;
    (assert) f"{num, .scientific}" == "3.140000e+00";
    (assert) f"{num, .scientific, precision=2}" == "3.14e+00";
}

*def minWidth~Test() {
    str := "String";
    (equal) f"{str, minWidth=10, fill=`*`}", "****String";
    (assert) f"{str, minWidth=10, fill=`*`, .left}" == "String****";
    (assert) f"{str, minWidth=10, fill=`*`, .center}" == "**String**";
    (assert) f"{str, minWidth=11, fill=`*`, .center}" == "**String***";

    (assert) f"{"128", minWidth=7, fill=`ə`, .center}" == "əə128əə";
    (assert) f"{"!", minWidth=3, fill=`😊`}" == "😊😊!";
}

*def maxWidthAndClipping~Test() {
    str := "Very long string";
    (equal) f"{str, maxWidth=10}", "Very lo...";
    (equal) f"{str, maxWidth=str'count'to(Int)}", "Very long string";
    (equal) f"{str, maxWidth=str'count'to(Int)-1}", "Very long st...";
    (equal) f"{str, maxWidth=5, clip="⚠⚠⚠"}", "Ve⚠⚠⚠";
    (equal) f"{str, maxWidth=2, clip="..."}", "...";
    (equal) f"{str, maxWidth=0, clip="..."}", "...";
}

*def widthAndClipping~Test() {
    str := "1234";
    (equal) f"{str, width=0, clip="?"}", "?";
    (equal) f"{str, width=0, clip="?"}", "?";
    (equal) f"{str, width=1, clip="?"}", "?";
    (equal) f"{str, width=2, clip="?"}", "1?";
    (equal) f"{str, width=3, clip="?"}", "12?";
    (equal) f"{str, width=4, clip="?"}", "1234";
    (equal) f"{str, width=6, clip="?", fill=`*`}", "**1234";
}

*def repeatingChars~Test() {
    (equal) f"{`A`, repeat=10u}", "AAAAAAAAAA";
    (equal) f"{`😊`, repeat=7u}", "😊😊😊😊😊😊😊";
    (equal) f"{`!`, repeat=0u}", "";
}
