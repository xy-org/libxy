import xytest;
import ..;

*func interpolatingChar~Test() {
    (assert) f"{`a`}" == "a";
    (assert) f"{`Ğ¶`}" == "Ğ¶";
    (assert) f"{`ğŸ˜Š`}xyz" == "ğŸ˜Šxyz";
    (assert) f"abc{`ğŸ˜Š`}" == "abcğŸ˜Š";
    (assert) f"before{`ğŸ˜Š`}after" == "beforeğŸ˜Šafter";
}

*func interpolatingStr~Test() {
    str := "John";
    (assert) f"My name is {str}" == "My name is John";

    # Case folding in unicode is a mess. For now I am going to
    # not bother implementing it.
    # (assert) f"My name is {str, .upper}" == "My name is JOHN";
    # (assert) f"My name is {str, .lower}" == "My name is john";
    # (assert) f"{str, fill=`*`, width=10, .center}" == "***John***";
}

*func strInterpolationUnicode~Test() {
    str := "Ğ™Ğ¾Ğ°Ğ½";
    (equal) f"My name is {str}", "My name is Ğ™Ğ¾Ğ°Ğ½";

    # Case folding in unicode is a mess. For now I am going to
    # not bother implementing it.
    # (equal) "My name is {str, .upper}", "My name is Ğ™ĞĞĞ";
    # (equal) "My name is {str, .lower}", "My name is Ğ¹Ğ¾Ğ°Ğ½";
    # (equal) "{str, fill=`âˆ`, width=6, .center}", "âˆĞ™Ğ¾Ğ°Ğ½âˆ";
}

*func interpolatingInt~Test() {
    (equal) f"{1b}", "1";
    (equal) f"{12ub}", "12";
    (equal) f"{123s}", "123";
    (equal) f"{4us}", "4";
    (equal) f"{12345}", "12345";
    (equal) f"{6u}", "6";
    (equal) f"{-1234567l}", "-1234567";
    (equal) f"{8ul}", "8";
    (equal) f"{369z}", "369";
}

*func interpolatingIntExplicitBase~Test() {
    (equal) f"{789024328ul, base=10}", "789024328";
    (equal) f"{789024328ul, base=16}", "2F078E48";
    (equal) f"{789024328ul, base=8}", "5701707110";
    (equal) f"{789024328ul, base=2}", "101111000001111000111001001000";
    (equal) f"{789024328ul, base=27}", "20QIFO7";
    (equal) f"{48461859, base=36}", "SUPER";
}

*func interpolatingBits~Test() {
    (equal) f"{0xFE()b'to(Bits8)}", "0xFE";
    (equal) f"{0x1234s'to(Bits16)}", "0x1234";
    (equal) f"{0x123456'to(Bits32)}", "0x00123456";
    (equal) f"{0x123456ABCDEFul'to(Bits64)}", "0x0000123456ABCDEF";
}

*func interpolatingFloat~Test() {
    (equal) f"{4125.6, precision=1}", "4125.6";
    (equal) f"{4125.6d}", "4125.6";
    (equal) f"{3.0}", "3";
    (equal) f"{3.0d, precision=1}", "3.0";
    (equal) f"{2.9, precision=0}", "3";
    (equal) f"{3.14, precision=-1}", "3.14";

    (equal) f"{Float'inf}", "inf";
    (equal) f"{Double'inf}", "inf";
    (equal) f"{-Double'inf}", "-inf";
    (equal) f"{Float'nan}", "nan";
    (equal) f"{-Double'nan}", "nan";
}

*func scientificNotation~Test() {
    num := 3.14;
    (assert) f"{num, .scientific}" == "3.140000e+00";
    (assert) f"{num, .scientific, precision=2}" == "3.14e+00";
}

*func minWidth~Test() {
    str := "String";
    (equal) f"{str, minWidth=10, fill=`*`}", "****String";
    (assert) f"{str, minWidth=10, fill=`*`, .left}" == "String****";
    (assert) f"{str, minWidth=10, fill=`*`, .center}" == "**String**";
    (assert) f"{str, minWidth=11, fill=`*`, .center}" == "**String***";

    (assert) f"{"128", minWidth=7, fill=`É™`, .center}" == "É™É™128É™É™";
    (assert) f"{"!", minWidth=3, fill=`ğŸ˜Š`}" == "ğŸ˜ŠğŸ˜Š!";
}

*func maxWidthAndClipping~Test() {
    str := "Very long string";
    (equal) f"{str, maxWidth=10}", "Very lo...";
    (equal) f"{str, maxWidth=str'count'to(Int)}", "Very long string";
    (equal) f"{str, maxWidth=str'count'to(Int)-1}", "Very long st...";
    (equal) f"{str, maxWidth=5, clip="âš âš âš "}", "Veâš âš âš ";
    (equal) f"{str, maxWidth=2, clip="..."}", "...";
    (equal) f"{str, maxWidth=0, clip="..."}", "...";
}

*func widthAndClipping~Test() {
    str := "1234";
    (equal) f"{str, width=0, clip="?"}", "?";
    (equal) f"{str, width=0, clip="?"}", "?";
    (equal) f"{str, width=1, clip="?"}", "?";
    (equal) f"{str, width=2, clip="?"}", "1?";
    (equal) f"{str, width=3, clip="?"}", "12?";
    (equal) f"{str, width=4, clip="?"}", "1234";
    (equal) f"{str, width=6, clip="?", fill=`*`}", "**1234";
}

*func repeatingChars~Test() {
    (equal) f"{`A`, repeat=10u}", "AAAAAAAAAA";
    (equal) f"{`ğŸ˜Š`, repeat=7u}", "ğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜Š";
    (equal) f"{`!`, repeat=0u}", "";
}

*func replacing~Test() {
    s : mut = "A unicode â™¡StringğŸ, and another String";
    (equal) f"{s, replace="String", by="Ping"}", "A unicode â™¡PingğŸ, and another Ping";
    (equal) f"{s, replace="ğŸ", by="â™¡"}", "A unicode â™¡Stringâ™¡, and another String";

    s = "ABğŸ";
    (equal) f"{s, replace="", by="â™¡"}", "â™¡Aâ™¡Bâ™¡ğŸâ™¡";

    s = "";
    (equal) f"{s, replace="", by="â™¡"}", "â™¡";
}