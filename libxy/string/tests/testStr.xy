import xytest;

*func charLen~Test() {
    (assert) "".size == 0;
    (assert) ""'count == 0;
    (assert) "\x00".size == 1;
    (assert) "\x00"'count == 1;
    (assert) "a".size == 1;
    (assert) "a"'count == 1;
    (assert) "abc".size == 3;
    (assert) "abc"'count == 3;
    (assert) "абв".size == 6;
    (assert) "абв"'count == 3;
    ;; https://unicode-explorer.com/emoji/military-medal
    (assert) "\U+1F396\U+FE0F".size == 7;
    (assert) "\U+1F396\U+FE0F"'count == 2;
}

*func charLenInvalidInput~Test() {
    ;; A truncated 3-byte code followed by a space.
    ;; Count the truncated code as 1 invalid symbol and the space as other.
    (assert) "\xE1\xA0\x20"'count == 2;

    ;; Truncated 3-byte codes
    (assert) "\xE1\xA0"'count == 1;
    (assert) "\xE1"'count == 1;

    ;; Truncated 3-byte codes multiple types
    (assert) "\xE1\xA0\xE1"'count == 2;

    ;; Invalid continuation byte
    (assert) "\xA0"'count == 1;
    (assert) "\xA0\x20"'count == 2;
}

*func iteratingChars~Test() {
    ;; U+0041 U+0411 U+304F U+0394
    str := "AБくΔ";
    expr := @{`A`, `Б`, `く`, `Δ`};
    i : Int;
    for (c in str'chars) {
        (equal) expr[i], c;
        i++;
    }
    charLen := i;
    (equal) charLen, 4;
}

*func iteratingWords~Test() {
    testSplitIter("word1 word2\nword3", @{"word1", "word2", "word3"});
}

*func splitting~Test() {
    i : Size;
    for (word in ""'split) {
        i++;
    }
    (equal) i, 0z;

    for (word in "   "'split) {
        i++;
    }
    (equal) i, 0z;

    for (word in "\{\n}?"'split) {
        i++;
    }
    (equal) i, 2z;
}

-func testSplitIter(
    str: Str, exp: pseudo @Str[],
    expAddr : Ptr~Str = exp'addrof, expLen : Usize = exp'len
) -> void {
    i : Size;
    for (word in str'split) {
        (equal) [expAddr + i], word;
        i++;
    }
    wordLen := i;
    (equal) wordLen, expLen;
}

*func finding~Test() {
    haystack := "haystacks are easy to search";

    (equal) haystack'find("hay"), 0z;
    (equal) haystack'find(haystack), 0z;
    (equal) haystack'find("stack"), 3z;
    (equal) haystack'find(" easy"), 13z;

    (equal) haystack'find("not-present"), -1z;

    longStr := "haystackshaystackshaystackshaystackshaystackshaystackshaystac";
    (equal) haystack'find(longStr), -1z;

    (equal) haystack'find(""), 0z;
    (equal) ""'find(""), 0z;
}

*func findingReverse~Test() {
    haystack := "haystacks are haystacks";

    (equal) haystack'find("hay", .reverse), 14z;
    (equal) haystack'find("s", .reverse), haystack.size - 1;
    (equal) haystack'find("stack", .reverse), 17z;
    (equal) "aaaa"'find("aaa", .reverse), 1z;

    (equal) haystack'find("not-present", .reverse), -1z;

    longStr := "haystackshaystackshaystackshaystackshaystackshaystackshaystac";
    (equal) haystack'find(longStr, .reverse), -1z;

    (equal) haystack'find("", .reverse), 0z;
    (equal) ""'find("", .reverse), 0z;
}
