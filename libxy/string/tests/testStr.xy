import xytest;
import libxy.slice;
import libxy.list;; For split/join tests

*func charLen~Test() {
    (assert) ""'memory.size == 0;
    (assert) ""'count == 0;
    (assert) "\x00"'memory.size == 1;
    (assert) "\x00"'count == 1;
    (assert) "a"'memory.size == 1;
    (assert) "a"'count == 1;
    (assert) "abc"'memory.size == 3;
    (assert) "abc"'count == 3;
    (assert) "–∞–±–≤"'memory.size == 6;
    (assert) "–∞–±–≤"'count == 3;
    ;; https://unicode-explorer.com/emoji/military-medal
    (assert) "\U+1F396\U+FE0F"'memory.size == 7;
    (assert) "\U+1F396\U+FE0F"'count == 2;
}

*func charLenInvalidInput~Test() {
    ;; A truncated 3-byte code followed by a space.
    ;; Count the truncated code as 1 invalid symbol and the space as other.
    (assert) "\xE1\xA0\x20"'count == 2;

    ;; Truncated 3-byte codes
    (assert) "\xE1\xA0"'count == 1;
    (assert) "\xE1"'count == 1;

    ;; Truncated 3-byte codes multiple types
    (assert) "\xE1\xA0\xE1"'count == 2;

    ;; Invalid continuation byte
    (assert) "\xA0"'count == 1;
    (assert) "\xA0\x20"'count == 2;
}

*func iteratingChars~Test() {
    ;; U+0041 U+0411 U+304F U+0394
    str := "A–ë„ÅèŒî";
    expr := @{`A`, `–ë`, `„Åè`, `Œî`};
    i : Int;
    for (c in str'chars) {
        (equal) expr[i], c;
        i++;
    }
    charLen := i;
    (equal) charLen, 4;
}

*func slicing~Test() {
    ;; U+0041 U+0042 U+304F
    str := "AB„Åè";
    (equal) str'str[0:1], "A"'str;
    (equal) str'str[1:2], "B"'str;
    (equal) str'str[2+:3], "„Åè"'str;
}

*func slicingOutOfBounds~Test() {
    str := "AB„Åè";
    (equal) str'str[-10:20], str'str;
    (equal) str'str[Int'min:Int'max], str'str;
    (equal) str'str[0:Int'max], str'str;
    (equal) str'str[Int'max:Int'min], ""'str;
}

*func splitting~Test() {
    (equal) "word1 word2 word3"'split, @{"word1", "word2", "word3"};

    (equal) "1,2,3"'split(","), @{"1", "2", "3"};
    (equal) "1,2,,3"'split(","), @{"1", "2", "", "3"};
    (equal) "1,2,,3"'split(",", +ignoreEmpty), @{"1", "2", "3"};
    (equal) "1,2,,"'split(","), @{"1", "2", "", ""};
    (equal) ",1,2,"'split(","), @{"", "1", "2", ""};
    (equal) ",1,2,"'split(",", +ignoreEmpty), @{"1", "2"};

    (equal) ""'split'len, 1z;
    (equal) ""'split(+ignoreEmpty)'len, 0z;

    (equal) ",,,"'split(",")'len, 4z;
    (equal) ",,,"'split(",", +ignoreEmpty)'len, 0z;

    (equal) "\{ }?"'split'len, 2z;
    (equal) "\{ }?"'split(+ignoreEmpty)'len, 2z;

    (equal) "1,2,3"'split(""), @{"", "1", ",", "2", ",", "3", ""};
    (equal) "1,2,3"'split("", +ignoreEmpty), @{"1", ",", "2", ",", "3"};

    (equal) ""'split(""), @{""};
    (equal) ""'split("", +ignoreEmpty)'len, 0;

    (equal) "üçè‚ô°üçè‚ô°üçè"'split("‚ô°"), @{"üçè", "üçè", "üçè"};
}

-func equal(
    actual: List~String, exp: pseudo @String[],
    expAddr : Ptr~String = exp'addrof, expLen : Usize = exp'len
) -> void {
    (equal) actual'len, expLen;

    i : Size;
    for (word in actual) {
        (equal) [expAddr + i], word;
        i++;
    }
}

*func checkingForSubstring~Test() {
    haystack := "haystacks are easy to search";

    (assert) haystack'has("hay");
    (assert) haystack'has(haystack);
    (assert) haystack'has("stack");
    (assert) haystack'has(" easy");

    (assert) haystack'has("not-present")'not;

    longStr := "haystackshaystackshaystackshaystackshaystackshaystackshaystac";
    (assert) haystack'has(longStr)'not;

    (assert) haystack'has("");
    (assert) ""'has("");
}

*func countingSubstrings~Test() {
    s := "A unicode ‚ô°Stringüçè, and another String";
    (equal) s'count("String"), 2;
    (equal) s'count("Stringüçè"), 1;
    (equal) s'count("S"), 2;
    (equal) s'count(""), 39;

    (equal) s'count("Not-Present"), 0;

    (equal) "aaaa" 'count("aa"), 2;
    (equal) "aaaaa" 'count("aa"), 2;
}
