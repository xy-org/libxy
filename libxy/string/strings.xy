import libc~[Clib{headers=@{"string.h", "stdio.h", "inttypes.h"}}] in c;
import libxy.(memory, error, slice, bitwise);

func cstr~[StrCtor{prefix="c", interpolation=false}] (
    addr: Ptr, size: Usize
)
    addr~[c.char];

;; A UTF-8 encoded string
*struct Str~[
    ;; Strings tagged with {MemManaged} have memory managed by {Str} itself
    ;; and have a trailing zero byte.
    ;;
    ;; Strings tagged with {MemExt} have memory not managed by {Str}
    ;; and no assumptions about the existence of a trailing zero byte.
    ;;
    ;; Strings tagged with {MemStatic} are allocated in static memory,
    ;; and have a trailing zero byte.
    memory : Any = void
] {
    addr: Ptr~Byte;
    size: Usize;; The byte-length of the string as encoding in UTF-8
}

*func dtor(str: Str) dtor(str, str..memory);

func dtor(str: Str, :MemManaged) {
    c.free(str.addr);
}

func dtor(str: Str, :MemExt) {}

func dtor(str: Str, :MemStatic) {}


func str~[StrCtor{prefix="", interpolation=false}] (
    addr: Ptr, size: Usize
) Str~MemStatic{addr, size};

*func get(s: Str, i: Usize) -> Byte
>> i < s.size
{
    return [(s.addr)~[to=Byte] + i];
}

;; Count the number of unicode code points (chars) in the string
;; Illegal byte sequences are counted as 1 code point
*func count(s: Str) -> Usize {
    res : Usize;
    i : Usize;
    while (i < s.size) {
        leadingOnes := s[i]'bits'countLeadingOnes;
        res++;
        i++;
        if (leadingOnes >= 2 && leadingOnes <= 4) {
            contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
            for (_ in 0:contBytes) {
                contOnes := s[i]'bits'countLeadingOnes;
                if (contOnes != 1 && contOnes <= 4) {
                    # premature end of current sequence. Break b/c
                    # a new sequence is following
                    break;
                }
                # else if {contOnes} == 1 then we have a valid seq
                # if {contOnes} is > 4 then we have a broken byte and we want
                # to skip it
                i++;
            }
        }
        ;; if {leadingOnes == 0} then ascii otherwise broken byte
    }
    return res;
}

*func get(s: Str, int: (RangeInt, RangeUint, RangeUlong)) -> Str~MemExt
>> int.start >= 0 && int.start <= int.end
{
    start := min(int.start'to(Usize), s.size);
    end := min(int.end'to(Usize), s.size);
    return Str~MemExt{s.addr + start, end - start};
}

;; Return true if string is empty
*func empty(s: Str) s.size == 0;

;; Retrun true if string is not empty
*func any(s: Str) s.size != 0;

*func cmp(str1: Str, str2: Str) -> Int {
    if (str1.size > str2.size) {
        return 1;
    } elif (str1.size < str2.size) {
        return -1;
    }
    return c.strncmp(str1.addr~[c.char], str2.addr~[c.char], str1.size);
}

*func startswith(str: Str, prefix: Str) -> Bool {
    if (prefix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char], prefix.addr~[c.char], prefix.size);
    return strncmpRes == 0;
}

*func endswith(str: Str, suffix: Str) -> Bool {
    if (suffix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char] + (str.size - suffix.size), suffix.addr~[c.char], suffix.size);
    return strncmpRes == 0;
}

*func ensureNullTerminated(str: Str) ensureNullTerminated(str, str..memory);
func ensureNullTerminated(str: Str, :MemManaged) str;
func ensureNullTerminated(str: Str, :MemStatic) str;
func ensureNullTerminated(str: Str, :MemExt) str'copy();

*func nullTerminated(str: Str) nullTerminated(str, str..(memory, MemExt));
func nullTerminated(str: Str, :MemManaged) true;
func nullTerminated(str: Str, :MemStatic) true;
func nullTerminated(str: Str, :MemExt) false;

*func copy(str: Str) -> Str~MemManaged {
    newmem : Memory;
    newmem'realloc(str.size + 1);
    c.memcpy(newmem.addr, str.addr, str.size);
    [newmem.addr + str.size] = 0;; add terminating \0
    return Str{addr=newmem.addr, size=str.size};
}

struct CharIter {
    i: Usize;; byte-offset of the code point after {char} in string
    char: Char;; character at that offset
}

*func get(str: Str, charIter: CharIter) = charIter.char;

;; Iterate of the unicode characters (code points) in {str}
;; Illegal byte sequences are replaced by U+FFFD
*func chars~IterCtor(str: Str) -> str[ CharIter ] {
    iter : CharIter;
    next(str, iter);
    return iter;
}

*func valid(str: Str, iter: CharIter) iter.char'to(Int) >= 0;

*func next(str: Str, iter: mut CharIter) {
    cp := decode(str, iter.i);
    iter.char = cp;
}

func decode(s: Str, i: mut Usize) -> Char {
    if (i >= s.size) {
        return (-1)'to(Char);
    }

    cp : Int;
    leadingByte := s[i];
    leadingOnes := leadingByte'bits'countLeadingOnes;
    i++;

    if (leadingOnes >= 2 && leadingOnes <= 4) {
        cp'bits = 0xFF'bits'shiftr(leadingOnes+1) && leadingByte'bits'to(Bits32);
        contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
        for (_ in 0:contBytes) {
            contOnes := s[i]'bits'countLeadingOnes;
            if (contOnes == 1) {
                cp'bits = cp'bits'shiftl(6) || (0x3Fub'bits && s[i]'bits)'to(Bits32);
            } elif (contOnes != 1 && contOnes <= 4) {
                # premature end of current sequence. Break b/c
                # a new sequence is following
                cp = -1;
                break;
            } else {
                # broken byte.
                cp = -1;
            }
            i++;
        }
    } elif (leadingOnes == 0) {
        ;; Ascii symbol
        cp = leadingByte'to(Int);
    } else {
        ;; Broken byte
        cp = -1;
    }

    if (cp < 0) {
        cp = 0xFFFD;; Replace invalid bytes by replacement char
    }

    return cp'to(Char);
}


;; Split by (white)space characters
*func split~IterCtor(str: Str) -> str[ SplitIter ] {
    si: mut = SplitIter{.valid};
    next(str, si);
    return si;
}

*func valid(str: Str, iter: SplitIter) = iter.valid;

*func get(str: Str, iter: SplitIter) = iter.word;

*func next(str: Str, iter: mut SplitIter) {
    istart := do -> (istart: Usize) {
        istart = iter.ichar.i;
        next(str, iter.ichar);
        if (!valid(str, iter.ichar)) {
            !.iter.valid;
            return;
        }
    } while (str[iter.ichar]'space);

    iend := do -> (iend: Usize) {
        iend = iter.ichar.i;
        next(str, iter.ichar);
        if (!valid(str, iter.ichar)) {
            break;
        }
    } while (!str[iter.ichar]'space);

    iter.word = Str~MemExt{str.addr + istart, iend - istart};
}

struct SplitIter {
    ichar: CharIter;
    word: Str~MemExt;
    valid: Bool;
}

*func space(ch: Char) -> Bool {
    return ch == `\n` || ch == ` `;
}
