import libc~[CLib{headers=@{"string.h", "stdio.h", "inttypes.h"}}] in c;
import libxy.memory;
import libxy.error;
import libxy.slice;
import libxy.bitwise;

def cstr~[StrCtor{prefix="c", interpolation=false}] (
    addr: Ptr, size: Size
)
    addr~[c.char];

;; Tag for strings that are managed by the Str struct itself.
;; Have trailing zero byte.
struct MemManaged {}

;; Tag for strings that are not managed by the Str struct itself.
;; No assumptions about the existence of a trailing zero byte.
struct MemExt {}

;; Tag for strings that are are allocated in static memory and need no free.
;; Have trailing zero byte.
struct MemStatic {}


;; A UTF-8 encoded string
*struct Str~[memory :struct = MemManaged] {
    addr: Ptr~Byte;
    len: Size;
}

*def dtor(str: Str) dtor(str, str..memory);

def dtor(str: Str, :MemManaged) {
    c.free(str.addr);
}

def dtor(str: Str, :MemExt) {}

def dtor(str: Str, :MemStatic) {}


def str~[StrCtor{prefix="", interpolation=false}] (
    addr: Ptr, size: Size
) Str~MemStatic{addr, size};

;; The byte-length of the string as encoding in UTF-8
*def len(s: Str) s.len;

*def get(s: Str, i: Size) -> Byte
>> i < s'len
{
    return [(s.addr)~[to=Byte] + i];
}

;; Count the number of unicode code points (chars) in the string
*def count(s: Str) -> Size {
    res : Size;
    i : Size;
    while (i < s.len) {
        contBytes := s[i]'bits'countLeadingOnes;
        res++;
        i++;
        if (contBytes >= 2 & contBytes <= 4) {
            for (j in 1:contBytes) {
                contOnes := s[i]'bits'countLeadingOnes;
                if (contOnes != 1 & contOnes <= 4) {
                    # premature end of current sequence. Break b/c
                    # a new sequence is following
                    break;
                }
                # else if {contOnes} == 1 then we have a valid seq
                # if {contOnes} is > 4 then we have a broken byte and we want
                # to skip it
                i++;
            }
        }
        ;; if contBytes == 0 then ascii otherwise broken byte
    }
    return res;
}

*def get(s: Str, int: SizeInterval) -> Str~MemExt
>> int.start <= s.len
>> (int.end - int.start) <= s.len
{
    return Str{s.addr + int.start, int.end - int.start};
}

*def cmp(str1: Str, str2: Str) -> Int {
    if (str1.len > str2.len) {
        return 1;
    } elif (str1.len < str2.len) {
        return -1;
    }
    return c.strncmp(str1.addr~[c.char], str2.addr~[c.char], str1.len);
}

*def cmpEq(str1: Str, str2: Str) cmp(str1, str2) == 0;
*def cmpNe(str1: Str, str2: Str) cmp(str1, str2) != 0;
*def cmpGt(str1: Str, str2: Str) cmp(str1, str2) > 0;
*def cmpGe(str1: Str, str2: Str) cmp(str1, str2) >= 0;
*def cmpLt(str1: Str, str2: Str) cmp(str1, str2) < 0;
*def cmpLe(str1: Str, str2: Str) cmp(str1, str2) <= 0;

*def startswith(str: Str, prefix: Str) -> Bool {
    if (prefix.len > str.len) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char], prefix.addr~[c.char], prefix.len);
    return strncmpRes == 0;
}

*def endswith(str: Str, suffix: Str) -> Bool {
    if (suffix.len > str.len) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char] + (str.len - suffix.len), suffix.addr~[c.char], suffix.len);
    return strncmpRes == 0;
}

*def ensureNullTerminated(str: Str) ensureNullTerminated(str, str..memory);
def ensureNullTerminated(str: Str, :MemManaged) str;
def ensureNullTerminated(str: Str, :MemStatic) str;
def ensureNullTerminated(str: Str, :MemExt) str'copy();

*def nullTerminated(str: Str) nullTerminated(str, str..memory);
def nullTerminated(str: Str, :MemManaged) true;
def nullTerminated(str: Str, :MemStatic) true;
def nullTerminated(str: Str, :MemExt) false;

*def copy(str: Str) -> Str {
    newmem : Memory;
    newmem'realloc(str.len + 1);
    c.memcpy(newmem.addr, str.addr, str.len);
    return Str{addr=newmem.addr, len=str.len};
}

*struct Fstr~[xy_dtor=true] {
    mem: Memory;
    len: Size;
}

*def dtor(builder: mut Fstr) {
    builder.mem'free();
}

*def fstr~[StrCtor{prefix="f", interpolation=true, to=Str}] (
    addr: pseudo Ptr, size: Size
) -> Fstr {
    return Fstr{};
}

def ensureCap(builder: mut Fstr, requiredCap: Size) {
    minSize := builder.len + requiredCap;
    if (builder.mem.size < minSize) {
        newSize : mut = 2 * builder.mem.size;
        if (newSize < minSize) {
            newSize = minSize;
        }
        builder.mem'realloc(newSize + 1);
    }
}

*def append(builder: mut Fstr, addr: Ptr, size: Size) {
    builder'ensureCap(size);
    c.memcpy(builder.mem.addr + builder.len, addr, size);
    builder.len += size;
}

*def append(builder: mut Fstr, str: Str) {
    builder'append(str.addr, str.len);
}

;; Number of available bytes in builder
def capacity(fstr: Fstr) fstr.mem.size - fstr.len;

def printfFmt(:Byte) inlinec"\"%\"PRId8";
def printfFmt(:Ubyte) inlinec"\"%\"PRIu8";
def printfFmt(:Short) inlinec"\"%\"PRId16";
def printfFmt(:Ushort) inlinec"\"%\"PRIu16";
def printfFmt(:Int) inlinec"\"%\"PRId32";
def printfFmt(:Uint) inlinec"\"%\"PRIu32";
def printfFmt(:Long) inlinec"\"%\"PRId64";
def printfFmt(:Ulong) inlinec"\"%\"PRIu64";
def printfFmt(:Size) inlinec"\"%zu\"";

*def append(builder: mut Fstr, num: (Byte, Ubyte, Short, Ushort, Int, Uint, Long, Ulong, Size)) {
    do {
        capacity := builder'capacity();
        added : Int = c.snprintf(builder.mem.addr~[c.char] + builder.len, capacity, num'printfFmt, num);
        if (added >= 0) {
            if (added'to(Size) >= capacity) {
                builder'ensureCap(added'to(Size) + 1);
            } else {
                builder.len += added'to(Size);
                break;
            }
        } else {
            break;  # I think it is safe to ignore this kind of error
        }
    } while(true);
}

*def append(builder: mut Fstr, num: Float, precision:=6) {
    builder'ensureCap(20z);
    added : Int = c.sprintf(builder.mem.addr~[c.char] + builder.len, c"%.*f", precision, num);
    builder.len += added'to(Size);
}

*def append(builder: mut Fstr, num: Double, precision:=6) {
    builder'ensureCap(20z);
    added : Int = c.sprintf(builder.mem.addr~[c.char] + builder.len, c"%.*f", precision, num);
    builder.len += added'to(Size);
}

*def backtrack(builder: mut Fstr, num: Uint) {
    builder.len -= num;
}

*def to(builder: mut Fstr, :Str) -> Str {
    builder'ensureCap(1z);
    ;; not really needed but better safe than sorry
    [builder.mem.addr~[c.char] + builder.len] = 0;
    res := Str{builder.mem.addr, builder.len};
    builder.mem =< Memory{};
    return res;
}
