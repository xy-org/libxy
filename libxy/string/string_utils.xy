;; === Searching and Replacing ===

;; Retrun true if {str} starts with the prefix {prefix}
*func startswith(str: String, prefix: String) -> Bool {
    if (prefix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char], prefix.addr~[c.char], prefix.size);
    return strncmpRes == 0;
}

;; Retrun true if {str} ends with the suffix {suffix}
*func endswith(str: String, suffix: String) -> Bool {
    if (suffix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char] + (str.size - suffix.size), suffix.addr~[c.char], suffix.size);
    return strncmpRes == 0;
}

;; Count the number of unicode code points (chars) in the string
;; Illegal byte sequences are counted as 1 code point
*func count(s: String) -> Usize {
    res : Usize;
    i : Usize;
    while (i < s.size) {
        leadingOnes := s.addr[i]'bits'countLeadingOnes;
        res++;
        i++;
        if (leadingOnes >= 2 && leadingOnes <= 4) {
            contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
            for (_ in 0:contBytes) {
                contOnes := s.addr[i]'bits'countLeadingOnes;
                if (contOnes != 1 && contOnes <= 4) {
                    # premature end of current sequence. Break b/c
                    # a new sequence is following
                    break;
                }
                # else if {contOnes} == 1 then we have a valid seq
                # if {contOnes} is > 4 then we have a broken byte and we want
                # to skip it
                i++;
            }
        }
        ;; if {leadingOnes == 0} then ascii otherwise broken byte
    }
    return res;
}

;; Count the number of non-overlapping occurances of {pattern} in {text}
;; If {pattern} is empty then the number of characters in {text} is returned.
*func count(text: String, pattern: String) -> (res: Usize) {
    if (pattern.size == 0) return text'count;

    nextStart: Usize;
    idx: mut = text'blob'find(pattern'blob);
    while (idx >= 0) {
        res++;
        nextStart += idx'to(Usize) + pattern.size;
        idx = text'bytes[nextStart:]'blob'find(pattern'blob);
    }
}

;; Replace the first {count} occurances of {old} in {text} with {new}
;; If {count} is negative then an unmodified copy of {text} is returned
*func replace(
    text: String, old: String, new: String, count := Size'max,
) -> String {
    if (count <= 0) return text'copy;

    #maxSubs := min(text'count(old), count'to(Usize));
    #newMem: Memory;
    #newMem'realloc(text.size - maxSubs * old.size + maxSubs * new.size + 1);
#
    #mem: mut = text.addr;
    #size: mut = text.size;
    #numSubs: %maxSubs;
    #while (numSubs < maxSubs) {
    #    numSubs++;
    #    idx := find()
    #}
}

;; === Splitting and Joining ===
# TODO split
# TODO splitlines
# TODO join


;; === String Classification ===
# TODO str.isAlpha
# TODO str.isDecimal
# TODO str.isDigit
# TODO str.isNumeric
# TODO str.isAlnum
# TODO str.isLower
# TODO str.isUpper
# TODO str.isTitle
# TODO str.isSpace
# TODO isPrintable(str and char)

;; === Case Manipulation ===
# TODO toLowerCase
# TODO toUpperCase
# TODO toTitleCase
# TODO capitalize

;; === Padding and Stripping ===

#TODO strip(chars)
