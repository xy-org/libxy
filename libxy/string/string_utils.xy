;; === Searching and Replacing ===

;; Retrun true if {str} starts with the prefix {prefix}
*func startswith(str: String, prefix: String) -> Bool {
    if (prefix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char], prefix.addr~[c.char], prefix.size);
    return strncmpRes == 0;
}

;; Retrun true if {str} ends with the suffix {suffix}
*func endswith(str: String, suffix: String) -> Bool {
    if (suffix.size > str.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(str.addr~[c.char] + (str.size - suffix.size), suffix.addr~[c.char], suffix.size);
    return strncmpRes == 0;
}

;; Count the number of unicode code points (chars) in the string
;; Illegal byte sequences are counted as 1 code point
*func count(s: String) -> Usize {
    res : Usize;
    i : Usize;
    while (i < s.size) {
        leadingOnes := s.addr[i]'bits'countLeadingOnes;
        res++;
        i++;
        if (leadingOnes >= 2 && leadingOnes <= 4) {
            contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
            for (_ in 0:contBytes) {
                contOnes := s.addr[i]'bits'countLeadingOnes;
                if (contOnes != 1 && contOnes <= 4) {
                    # premature end of current sequence. Break b/c
                    # a new sequence is following
                    break;
                }
                # else if {contOnes} == 1 then we have a valid seq
                # if {contOnes} is > 4 then we have a broken byte and we want
                # to skip it
                i++;
            }
        }
        ;; if {leadingOnes == 0} then ascii otherwise broken byte
    }
    return res;
}

;; Count the number of non-overlapping occurances of {pattern} in {text}
;;
;; If {pattern} is empty then the number of chars in {text} + 1 is returned.
;; The idea being that an empty string can be found between any two chars
;; and between the beginning/end and first/last char
*func count(text: String, pattern: String) -> (res: Usize) {
    if (pattern.size == 0) return text'count + 1;

    nextStart: Usize;
    idx: mut = text'blob'find(pattern'blob);
    while (idx >= 0) {
        res++;
        nextStart += idx'to(Usize) + pattern.size;
        idx = text'bytes[nextStart:]'blob'find(pattern'blob);
    }
}

;; Replace the first {count} occurances of {old} in {text} with {new}
;; If {count} is negative then an unmodified copy of {text} is returned
*func replace(
    text: String, old: String, new: String, count := Size'max,
) -> String {
    if (count <= 0) return text'copy;

    numSubs := min(text'count(old), count'to(Usize));
    res: Fstring;
    res'ensureCap(text.size - numSubs * old.size + numSubs * new.size + 1);

    ;; old being empty is a degenerate case and we handle it differently
    if (old'isEmpty) {
        replaceEmpty(text, new, numSubs, res);
        return res'to(String);
    }

    textPos: Usize;
    for (i in :numSubs) {
        idx := text'bytes[textPos:]'memory'find(old'memory);
        if (idx >= 0) {
            newPos := textPos + idx'to(%textPos);
            res'append(text'bytes[textPos:newPos]);
            res'append(new);
            textPos = newPos + max(old.size, 1uz);
        }
    }
    res'append(text'bytes[textPos:]);

    return res'to(String);
}

;; Handle the degenerate case of replacing an empty string
-func replaceEmpty(text: String, new: String, numSubs: Usize, res: Fstring) {
    i: %numSubs;
    for (char in text'chars) {
        if (i < numSubs) {
            res'append(new);
            i++;
        }
        res'append(char);
    }
    if (i < numSubs) {
        res'append(new);
    }
}

;; === Splitting and Joining ===
# TODO split
# TODO splitlines
# TODO join


;; === String Classification ===
# TODO str.isAlpha
# TODO str.isDecimal
# TODO str.isDigit
# TODO str.isNumeric
# TODO str.isAlnum
# TODO str.isLower
# TODO str.isUpper
# TODO str.isTitle
# TODO str.isSpace
# TODO isPrintable(str and char)

;; === Case Manipulation ===
# TODO toLowerCase
# TODO toUpperCase
# TODO toTitleCase
# TODO capitalize

;; === Padding and Stripping ===

#TODO strip(chars)
