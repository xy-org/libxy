;; === Searching and Replacing ===

;; Retrun true if {text} starts with the prefix {prefix}
*func startswith(text: Str, prefix: Str) -> Bool {
    if (prefix.size > text.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(text.addr~[c.char], prefix.addr~[c.char], prefix.size);
    return strncmpRes == 0;
}

;; ...
*func startswith(text: String, prefix: String) =
    startswith(text'str, prefix'str);


;; Retrun true if {text} ends with the suffix {suffix}
*func endswith(text: Str, suffix: Str) -> Bool {
    if (suffix.size > text.size) {
        return false;
    }
    strncmpRes: Int = c.strncmp(
        text.addr~[c.char] + (text.size - suffix.size),
        suffix.addr~[c.char], suffix.size
    );
    return strncmpRes == 0;
}

;; ...
*func endswith(str: String, suffix: String) = endswith(str'str, suffix'str);

;; Count the number of unicode code points (chars) in the string
;; Illegal byte sequences are counted as 1 code point
*func count(s: Str) -> Usize {
    res : Usize;
    i : Usize;
    while (i < s.size) {
        leadingOnes := s.addr[i]'bits'countLeadingOnes;
        res++;
        i++;
        if (leadingOnes >= 2 && leadingOnes <= 4) {
            contBytes := min((leadingOnes - 1)'to(Usize), s.size - i);
            for (_ in 0:contBytes) {
                contOnes := s.addr[i]'bits'countLeadingOnes;
                if (contOnes != 1 && contOnes <= 4) {
                    # premature end of current sequence. Break b/c
                    # a new sequence is following
                    break;
                }
                # else if {contOnes} == 1 then we have a valid seq
                # if {contOnes} is > 4 then we have a broken byte and we want
                # to skip it
                i++;
            }
        }
        ;; if {leadingOnes == 0} then ascii otherwise broken byte
    }
    return res;
}

;; ...
*func count(s: String) = s'str'count;


;; Count the number of non-overlapping occurances of {pattern} in {text}
;;
;; If {pattern} is empty then the number of chars in {text} + 1 is returned.
;; The idea being that an empty string can be found between any two chars
;; and between the beginning/end and first/last char
*func count(text: Str, pattern: Str) -> (res: Usize) {
    if (pattern.size == 0) return text'count + 1;

    nextStart: Usize;
    idx: mut = text'memory'find(pattern'memory);
    while (idx >= 0) {
        res++;
        nextStart += idx'to(Usize) + pattern.size;
        idx = text[nextStart:]'memory'find(pattern'memory);
    }
}

;; ...
*func count(text: String, pattern: String) = count(text'str, pattern'str);

;; === Splitting and Joining ===
# TODO split
# TODO splitlines
# TODO join


;; === String Classification ===
# TODO str.isAlpha
# TODO str.isDecimal
# TODO str.isDigit
# TODO str.isNumeric
# TODO str.isAlnum
# TODO str.isLower
# TODO str.isUpper
# TODO str.isTitle
# TODO str.isSpace
# TODO isPrintable(str and char)

;; === Case Manipulation ===
# TODO toLowerCase
# TODO toUpperCase
# TODO toTitleCase
# TODO capitalize

;; === Padding and Stripping ===

#TODO strip(chars)
